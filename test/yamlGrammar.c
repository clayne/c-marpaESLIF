#ifndef YAML_GRAMMAR_C
#define YAML_GRAMMAR_C

const static char *yamls = "\n"
  "event ^ns_plain_char = predicted <ns plain char><--(c)\n"
  "event ^s_separate = predicted <s separate><--(n,c)\n"
  "event ^l_yaml_stream = predicted <l yaml stream>\n"
  "#\n"
  "# Reference: https://yaml.org/spec/1.2.2/\n"
  "#\n"
  ":default ::= fallback-encoding => UTF-8 event-action => ::luac->function(events)\n"
  "                                                                  print(tableDump(events))\n"
  "                                                                  return true\n"
  "                                                                end\n"
  ":start   ::= <l yaml stream>\n"
  ":desc    ::= 'YAML'\n"
  "\n"
  "\n"
  "#\n"
  "# Special productions\n"
  "#\n"
  "<start of line> ::= :sol\n"
  "<end of input>  ::= :eof\n"
  "<empty>         ::= :empty\n"
  "\n"
  "\n"
  "/* [1] */ <c printable> ::=\n"
  "                              # 8 bit\n"
  "    [\\x{09}]                  # Tab (\\t)\n"
  "  | [\\x{0A}]                  # Line feed (LF \\n)\n"
  "  | [\\x{0D}]                  # Carriage Return (CR \\r)\n"
  "  | [\\x{20}-\\x{7E}]           # Printable ASCII\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FFFD}]:u     # Additional Unicode Areas\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "\n"
  "/* [2] */ <nb json> ::=\n"
  "    [\\x{09}]                  # Tab character\n"
  "  | [\\x{20}-\\x{10FFFF}]:u     # Non-C0-control characters\n"
  "\n"
  "/* [3] */ <c byte order mark> ::= [\\x{FEFF}]:u\n"
  "/* [4] */ <c sequence entry>  ::= '-'\n"
  "/* [5] */ <c mapping key>     ::= '?'\n"
  "/* [6] */ <c mapping value>   ::= ':'\n"
  "/* [7] */ <c collect entry>   ::= ','\n"
  "/* [8] */ <c sequence start>  ::= '['\n"
  "/* [9] */ <c sequence end>    ::= ']'\n"
  "/* [10] */ <c mapping start>  ::= '{'\n"
  "/* [11] */ <c mapping end>    ::= '}'\n"
  "/* [12] */ <c comment>        ::= '#'\n"
  "/* [13] */ <c anchor>         ::= '&'\n"
  "/* [14] */ <c alias>          ::= '*'\n"
  "/* [15] */ <c tag>            ::= '!'\n"
  "/* [16] */ <c literal>        ::= '|'\n"
  "/* [17] */ <c folded>         ::= '>'\n"
  "/* [18] */ <c single quote>   ::= \"'\"\n"
  "/* [19] */ <c double quote>   ::= '\"'\n"
  "/* [20] */ <c directive>      ::= '%'\n"
  "/* [21] */ <c reserved>       ::= '@' | '`'\n"
  "/* [22] */ <c indicator>      ::=\n"
  "    <c sequence entry>    # '-'\n"
  "  | <c mapping key>       # '?'\n"
  "  | <c mapping value>     # ':'\n"
  "  | <c collect entry>     # ','\n"
  "  | <c sequence start>    # '['\n"
  "  | <c sequence end>      # ']'\n"
  "  | <c mapping start>     # '{'\n"
  "  | <c mapping end>       # '}'\n"
  "  | <c comment>           # '#'\n"
  "  | <c anchor>            # '&'\n"
  "  | <c alias>             # '*'\n"
  "  | <c tag>               # '!'\n"
  "  | <c literal>           # '|'\n"
  "  | <c folded>            # '>'\n"
  "  | <c single quote>      # \"'\"\n"
  "  | <c double quote>      # '\"'\n"
  "  | <c directive>         # '%'\n"
  "  | <c reserved>          # '@' '`'\n"
  "/* [23] */ <c flow indicator> ::=\n"
  "    <c collect entry>     # ','\n"
  "  | <c sequence start>    # '['\n"
  "  | <c sequence end>      # ']'\n"
  "  | <c mapping start>     # '{'\n"
  "  | <c mapping end>       # '}'\n"
  "/* [24] */ <b line feed> ::= [\\x{0A}]\n"
  "/* [25] */ <b carriage return> ::= [\\x{0D}]\n"
  "/* [26] */ <b char> ::=\n"
  "    <b line feed>          # x0A\n"
  "  | <b carriage return>    # x0D\n"
  "/* [27] */ <nb char> ::=      /* <c printable> - ( <b char> | <c byte order mark> ) */\n"
  "                              # 8 bit\n"
  "    [\\x{09}]                  # Tab (\\t)\n"
  "  | [\\x{20}-\\x{7E}]           # Printable ASCII\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "/* [28] */ <b break> ::=\n"
  "    <b carriage return>  # x0A\n"
  "    <b line feed>        # x0D\n"
  "  | <b carriage return>\n"
  "  | <b line feed>\n"
  "/* [29] */ <b as line feed> ::=\n"
  "  <b break>\n"
  "/* [30] */ <b non content> ::=\n"
  "  <b break>\n"
  "/* [31] */ <s space> ::= [\\x{20}]\n"
  "/* [32] */ <s tab> ::= [\\x{09}]\n"
  "/* [33] */ <s white> ::=\n"
  "    <s space>\n"
  "  | <s tab>\n"
  "/* [34] */ <ns char> ::= /* <nb char> - <s white> */\n"
  "                              # 8 bit\n"
  "   [\\x{21}-\\x{7E}]           # Printable ASCII minus <s space>\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "/* [35] */ <ns dec digit> ::=\n"
  "  [\\x{30}-\\x{39}]             # 0-9\n"
  "/* [36] */ <ns hex digit> ::=\n"
  "    <ns dec digit>        # 0-9\n"
  "  | [\\x{41}-\\x{46}]           # A-F\n"
  "  | [\\x{61}-\\x{66}]           # a-f\n"
  "/* [37] */ <ns ascii letter> ::=\n"
  "    [\\x{41}-\\x{5A}]           # A-Z\n"
  "  | [\\x{61}-\\x{7A}]           # a-z\n"
  "/* [38] */ <ns word char> ::=\n"
  "    <ns dec digit>        # 0-9\n"
  "  | <ns ascii letter>     # A-Z a-z\n"
  "  | '-'                 # '-'\n"
  "/* [39] */ <ns uri char> ::=\n"
  "    '%' <ns hex digit> <ns hex digit>\n"
  "  | <ns word char>\n"
  "  | '#'\n"
  "  | ';'\n"
  "  | '/'\n"
  "  | '?'\n"
  "  | ':'\n"
  "  | '@'\n"
  "  | '&'\n"
  "  | '='\n"
  "  | '+'\n"
  "  | '$'\n"
  "  | ','\n"
  "  | '_'\n"
  "  | '.'\n"
  "  | '!'\n"
  "  | '~'\n"
  "  | '*'\n"
  "  | \"'\"\n"
  "  | '('\n"
  "  | ')'\n"
  "  | '['\n"
  "  | ']'\n"
  "/* [40] */ <ns tag char> ::= /* <ns uri char> - <c tag> - <c flow indicator> */\n"
  "    '%' <ns hex digit> <ns hex digit>\n"
  "  | <ns word char>\n"
  "  | '#'\n"
  "  | ';'\n"
  "  | '/'\n"
  "  | '?'\n"
  "  | ':'\n"
  "  | '@'\n"
  "  | '&'\n"
  "  | '='\n"
  "  | '+'\n"
  "  | '$'\n"
  "  | '_'\n"
  "  | '.'\n"
  "  | '~'\n"
  "  | '*'\n"
  "  | \"'\"\n"
  "  | '('\n"
  "  | ')'\n"
  "/* [41] */ <c escape> ::= '\\\\'\n"
  "/* [42] */ <ns esc null> ::= '0'\n"
  "/* [43] */ <ns esc bell> ::= 'a'\n"
  "/* [44] */ <ns esc backspace> ::= 'b'\n"
  "/* [45] */ <ns esc horizontal tab> ::=\n"
  "    't'\n"
  "  | [\\x{09}]\n"
  "/* [46] */ <ns esc line feed> ::= 'n'\n"
  "/* [47] */ <ns esc vertical tab> ::= 'v'\n"
  "/* [48] */ <ns esc form feed> ::= 'f'\n"
  "/* [49] */ <ns esc carriage return> ::= 'r'\n"
  "/* [50] */ <ns esc escape> ::= 'e'\n"
  "/* [51] */ <ns esc space> ::= [\\x{20}]\n"
  "/* [52] */ <ns esc double quote> ::= '\"'\n"
  "/* [53] */ <ns esc slash> ::= '/'\n"
  "/* [54] */ <ns esc backslash> ::= '\\\\'\n"
  "/* [55] */ <ns esc next line> ::= 'N'\n"
  "/* [56] */ <ns esc non breaking space> ::= '_'\n"
  "/* [57] */ <ns esc line separator> ::= 'L'\n"
  "/* [58] */ <ns esc paragraph separator> ::= 'P'\n"
  "/* [59] */ <ns esc 8 bit> ::=\n"
  "  'x' <ns hex digit> <ns hex digit>\n"
  "/* [60] */ <ns esc 16 bit> ::=\n"
  "  'u' <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit>\n"
  "/* [61] */ <ns esc 32 bit> ::=\n"
  "  'U' <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit> <ns hex digit>\n"
  "/* [62] */ <c ns esc char> ::=\n"
  "  <c escape>         # '\\'\n"
  "  (\n"
  "      <ns esc null>\n"
  "    | <ns esc bell>\n"
  "    | <ns esc backspace>\n"
  "    | <ns esc horizontal tab>\n"
  "    | <ns esc line feed>\n"
  "    | <ns esc vertical tab>\n"
  "    | <ns esc form feed>\n"
  "    | <ns esc carriage return>\n"
  "    | <ns esc escape>\n"
  "    | <ns esc space>\n"
  "    | <ns esc double quote>\n"
  "    | <ns esc slash>\n"
  "    | <ns esc backslash>\n"
  "    | <ns esc next line>\n"
  "    | <ns esc non breaking space>\n"
  "    | <ns esc line separator>\n"
  "    | <ns esc paragraph separator>\n"
  "    | <ns esc 8 bit>\n"
  "    | <ns esc 16 bit>\n"
  "    | <ns esc 32 bit>\n"
  "  )\n"
  "\n"
  "/* [63] */ <s indent><--(n) ::= . =>\n"
  "                     ::luac->function(n)\n"
  "                               print('===========> <s indent><--('..tostring(n)..' [type: '..type(n)..'])')\n"
  "                               if (n <= 0) then\n"
  "                                 return [[\n"
  "                                          <empty>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 return [[\n"
  "                                          <s space> <s indent>-->(n-1)\n"
  "                                        ]]\n"
  "                               end\n"
  "                             end -->(n)\n"
  "/* [64] */ <s indent less than><--(n) ::= . =>\n"
  "                     ::luac->function(n)\n"
  "                               print('===========> <s indent less than><--('..tostring(n)..' [type: '..type(n)..'])')\n"
  "                               if (n <= 1) then\n"
  "                                 return [[\n"
  "                                          <empty>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 return [[\n"
  "                                          ( <s space> <s indent less than>-->(n-1) | <empty> )\n"
  "                                        ]]\n"
  "                               end\n"
  "                             end -->(n)\n"
  "/* [65] */ <s indent less or equal><--(n) ::= . =>\n"
  "                     ::luac->function(n)\n"
  "                               print('===========> <s indent less or equal><--('..tostring(n)..' [type: '..type(n)..'])')\n"
  "                               if (n <= 0) then\n"
  "                                 return [[\n"
  "                                          <empty>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 return [[\n"
  "                                          ( <s space> <s indent less or equal>-->(n-1) | <empty> )\n"
  "                                        ]]\n"
  "                               end\n"
  "                             end -->(n)\n"
  "/* [66] */ <s separate in line> ::=\n"
  "    ( <s white> +)\n"
  "  | <start of line>\n"
  "\n"
  "/* [67] */ <s line prefix><--(n,c) ::= . =>\n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <s line prefix><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'BLOCK-OUT') then\n"
  "                                 return [[\n"
  "                                          <s block line prefix>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-IN') then\n"
  "                                 return [[\n"
  "                                          <s block line prefix>-->(n)\n"
  "                                        ]]\n"
  "\n"
  "                               elseif (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <s flow line prefix>-->(n)\n"
  "                                        ]]\n"
  "\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <s flow line prefix>-->(n)\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<s line prefix>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "\n"
  "/* [68] */ <s block line prefix><--(n) ::= <s indent>-->(n)\n"
  "\n"
  "/* [69] */ <s flow line prefix><--(n) ::= <s indent>-->(n) <s separate in line>\n"
  "                                        | <s indent>-->(n)\n"
  "\n"
  "/* [70] */ <l empty><--(n,c) ::= <s line prefix>-->(n,c)    <b as line feed>\n"
  "                               | <s indent less than>-->(n) <b as line feed>\n"
  "/* [71] */ <b l trimmed><--(n,c) ::= <b non content> ( <l empty>-->(n,c)+ )\n"
  "/* [72] */ <b as space> ::= <b break>\n"
  "/* [73] */ <b l folded><--(n,c) ::= <b l trimmed>-->(n,c) | <b as space>\n"
  "/* [74] */ <s flow folded><--(n) ::= <s separate in line> <b l folded>-->(n,'FLOW-IN') <s flow line prefix>-->(n)\n"
  "                                   | <b l folded>-->(n,'FLOW-IN') <s flow line prefix>-->(n)\n"
  "/* [75] */ <c nb comment text> ::= <c comment> /* '#' */ ( <nb char>* )\n"
  "/* [76] */ <b comment> ::= <b non content>\n"
  "                         | <end of input>\n"
  "\n"
  "/* [77] */ <s b comment> ::= ( <s separate in line> <c nb comment text> | <s separate in line> ) <b comment>\n"
  "                           |                                                                     <b comment>\n"
  "\n"
  "/* [78] */ <l comment> ::= <s separate in line> <c nb comment text> <b comment>\n"
  "                         | <s separate in line>                     <b comment>\n"
  "\n"
  "/* [79] */ <s l comments> ::= ( <s b comment> | <start of line> ) ( <l comment>*) \n"
  "\n"
  "/* [80] */ <s separate><--(n,c) ::= . =>\n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <s separate><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'BLOCK-OUT') then\n"
  "                                 return [[\n"
  "                                          <s separate lines>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-IN') then\n"
  "                                 return [[\n"
  "                                          <s separate lines>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <s separate lines>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <s separate lines>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <s separate in line>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <s separate in line>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<s separate>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "\n"
  "/* [81] */ <s separate lines><--(n) ::= <s l comments> <s flow line prefix>-->(n) | <s separate in line>\n"
  "\n"
  "\n"
  "/* [82] */ <l directive> ::= <c directive> /* '%' */ ( <ns yaml directive> | <ns tag directive> | <ns reserved directive> ) <s l comments>\n"
  "/* [83] */ <ns reserved directive> ::= <ns directive name unit>*\n"
  "/* [84] */ <ns directive name> ::= <ns char>+\n"
  "/* [85] */ <ns directive parameter> ::= <ns char>+\n"
  "/* [86] */ <ns yaml directive> ::= \"YAML\" <s separate in line> <ns yaml version>\n"
  "/* [87] */ <ns yaml version> ::= ( <ns dec digit>+ ) '.' ( <ns dec digit> +)\n"
  "/* [88] */ <ns tag directive> ::= \"TAG\" <s separate in line> <c tag handle> <s separate in line> <ns tag prefix>\n"
  "/* [89] */ <c tag handle> ::= <c named tag handle>\n"
  "                            | <c secondary tag handle>\n"
  "                            | <c primary tag handle>\n"
  "/* [90] */ <c primary tag handle> ::= '!'\n"
  "/* [91] */ <c secondary tag handle> ::= \"!!\"\n"
  "/* [92] */ <c named tag handle> ::= <c tag> /* '!' */ ( <ns word char>+ ) <c tag> /* '!' */\n"
  "/* [93] */ <ns tag prefix> ::= <c ns local tag prefix>\n"
  "                             | <ns global tag prefix>\n"
  "/* [94] */ <c ns local tag prefix> ::= <c tag> /*'!' */ ( <ns uri char>* )\n"
  "/* [95] */ <ns global tag prefix> ::= <ns tag char> ( <ns uri char>* )\n"
  "/* [96] */ <c ns properties><--(n,c) ::= <c ns tag property>\n"
  "                                       | <c ns tag property> <s separate>-->(n,c) <c ns anchor property>\n"
  "                                       | <c ns anchor property>\n"
  "                                       | <c ns anchor property> <s separate>-->(n,c) <c ns tag property>\n"
  "/* [97] */ <c ns tag property> ::= <c verbatim tag>\n"
  "                                 | <c ns shorthand tag>\n"
  "                                 | <c non specific tag>\n"
  "/* [98] */ <c verbatim tag> ::= \"!<\" ( <ns uri char>+ ) '>'\n"
  "/* [99] */ <c ns shorthand tag> ::= <c tag handle> ( <ns tag char>+ )\n"
  "/* [100] */ <c non specific tag> ::= '!'\n"
  "/* [101] */ <c ns anchor property> ::= <c anchor> /* '&' */ <ns anchor name>\n"
  "\n"
  "/* [102] */ <ns anchor char> ::= /* <ns char> - <c flow indicator> */\n"
  "                              # 8 bit\n"
  "   [\\x{21}-\\x{2B}\\x{2D}-\\x{5A}\\x{5C}\\x{5E}-\\x{7A}\\x{7C}\\x{7E}]           # Printable ASCII minus ',', '[', ']', '{', '}'\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "/* [103] */ <ns anchor name> ::= ( <ns anchor char>+)\n"
  "/* [104] */ <c ns alias node> ::= <c alias> /* '*' */ <ns anchor name>\n"
  "/* [105] */ <e scalar> ::= <empty>\n"
  "/* [106] */ <e node> ::= <e scalar> # \"\"\n"
  "/* [107] */ <nb double char> ::=\n"
  "    <c ns esc char>\n"
  "  | ( # <nb json> - <c escape> /* '\\' */ - <c double quote>  /* '\"' */\n"
  "        [\\x{09}]                  # Tab character\n"
  "      | [\\x{20}\\x{21}\\x{23}-\\x{5B}\\x{5D}-\\x{10FFFF}]:u     # Non-C0-control characters minus \\ and \"\n"
  "    )\n"
  "\n"
  "/* [108] */ <ns double char> ::= /* <nb double char> - <s white> */\n"
  "    <c ns esc char>\n"
  "  | (\n"
  "      [\\x{21}\\x{23}-\\x{5B}\\x{5D}-\\x{10FFFF}]:u     # Non-C0-control characters minus \\, \", space and tab\n"
  "    )\n"
  "/* [109] */ <c double quoted><--(n,c) ::=\n"
  "  <c double quote> # '\"'\n"
  "  <nb double text>-->(n,c)\n"
  "  <c double quote>         # '\"'\n"
  "/* [110] */ <nb double text><--(n,c) ::= . => \n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <nb double text><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <nb double multi line>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <nb double multi line>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <nb double one line>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <nb double one line>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<nb double text>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "/* [111] */ <nb double one line> ::= <nb double char>*\n"
  "/* [112] */ <s double escaped><--(n) ::=\n"
  "  ( <s white>* )\n"
  "  <c escape>         # '\\'\n"
  "  <b non content>\n"
  "  ( <l empty>-->(n,'FLOW-IN')* )\n"
  "  <s flow line prefix>-->(n)\n"
  "\n"
  "/* [113] */ <s double break><--(n) ::=\n"
  "    <s double escaped>-->(n)\n"
  "  | <s flow folded>-->(n)\n"
  "\n"
  "/* [114] */ <nb ns double in line> ::= <nb ns double in line unit>*\n"
  "/* [115] */ <s double next line><--(n) ::=\n"
  "    <s double break>-->(n)\n"
  "  | <s double break>-->(n) \n"
  "  (\n"
  "    <ns double char> <nb ns double in line>\n"
  "    (\n"
  "        <s double next line>-->(n)\n"
  "      | ( <s white>* )\n"
  "    )\n"
  "  )\n"
  "/* [116] */ <nb double multi line><--(n) ::=\n"
  "  <nb ns double in line>\n"
  "  (\n"
  "      <s double next line>-->(n)\n"
  "    | ( <s white>* )\n"
  "  )\n"
  "/* [117] */ <c quoted quote> ::= \"''\"\n"
  "/* [118] */ <nb single char> ::=\n"
  "    <c quoted quote>\n"
  "  | ( # <nb json> - <c single quote> /* \"'\" */\n"
  "        [\\x{09}]                               # Tab character\n"
  "      | [\\x{20}-\\x{26}\\x{28}-\\x{10FFFF}]:u     # Non-C0-control characters minus '\n"
  "    )\n"
  "/* [119] */ <ns single char> ::= # <nb single char> - <s white>\n"
  "    <c quoted quote>\n"
  "  | ( # <nb json> - <c single quote> /* \"'\" */\n"
  "      [\\x{21}-\\x{26}\\x{28}-\\x{10FFFF}]:u     # Non-C0-control characters minus ', space and tab\n"
  "    )\n"
  "/* [120] */ <c single quoted><--(n,c) ::=\n"
  "  <c single quote>    # \"'\"\n"
  "  <nb single text>-->(n,c)\n"
  "  <c single quote>    # \"'\"\n"
  "/* [121] */\n"
  "<nb single text><--(n,c) ::= . =>\n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <nb single text><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <nb single multi line>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <nb single multi line>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <nb single one line>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <nb single one line>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<nb single text>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "/* [122] */ <nb single one line> ::= <nb single char>*\n"
  "/* [123] */ <nb ns single in line> ::= <nb ns single in line unit>*\n"
  "/* [124] */ <s single next line><--(n) ::=\n"
  "    <s flow folded>-->(n)\n"
  "  | <s flow folded>-->(n)\n"
  "    (\n"
  "      <ns single char>\n"
  "      <nb ns single in line>\n"
  "      (\n"
  "          <s single next line>-->(n)\n"
  "        | ( <s white>* )\n"
  "      )\n"
  "    )\n"
  "/* [125] */ <nb single multi line><--(n) ::=\n"
  "  <nb ns single in line>\n"
  "  (\n"
  "      <s single next line>-->(n)\n"
  "    | ( <s white>* )\n"
  "  )\n"
  "/* [126] */ <ns plain first><--(c) ::=\n"
  "    ( # <ns char> - <c indicator>\n"
  "                                  # 8 bit\n"
  "        [\\x{24}\\x{26}\\x{28}\\x{29}\\x{2B}\\x{2E}-\\x{39}\\x{3B}-\\x{3D}\\x{41}-\\x{5A}\\x{5C}\\x{5E}\\x{5F}\\x{61}-\\x{7A}\\x{7E}]           # Printable ASCII minus <s space>, '-', '?', ':', ',', '[', ']', '{', '}', '#', '&', '*', '!', '|', '>', \"'\", '\"', '%', '@' and '`'\n"
  "                                  # 16 bit\n"
  "      | [\\x{85}]                  # Next Line (NEL)\n"
  "      | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "      | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "      | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "        \n"
  "    )\n"
  "  | (\n"
  "      (\n"
  "          <c mapping key>       # '?'\n"
  "        | <c mapping value>     # ':'\n"
  "        | <c sequence entry>    # '-'\n"
  "      )\n"
  "      (?=<ns plain safe>-->(c))\n"
  "    )\n"
  "/* [127] */ <ns plain safe><--(c) ::= . => \n"
  "                     ::luac->function(c)\n"
  "                               print('===========> <ns plain safe><--('..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe out>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe in>\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe out>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe in>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<ns plain safe>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(c)\n"
  "/* [128] */ <ns plain safe out> ::= <ns char>\n"
  "/* [129] */ <ns plain safe in> ::= # <ns char> - <c flow indicator>\n"
  "                              # 8 bit\n"
  "   [\\x{21}-\\x{2B}\\x{2D}-\\x{5A}\\x{5C}\\x{5E}-\\x{7A}\\x{7C}\\x{7E}]           # Printable ASCII minus <s space>, ',', '[', ']', '{', '}'\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "\n"
  "/* [130] */ <ns plain char><--(c) ::=\n"
  "    ( # <ns plain safe>-->(c) - <c mapping value> /* ':' */ - <c comment> /* '#' */\n"
  "      <ns plain safe minus c mapping value and c comment>-->(c)\n"
  "    )\n"
  "  | (\n"
  "      /* [ lookbehind = ns-char ] */\n"
  "      <c comment>          # '#'\n"
  "    )\n"
  "  | (\n"
  "      <c mapping value> # ':'\n"
  "      (?=<ns plain safe>-->(c))\n"
  "    )\n"
  "/* [131] */\n"
  "<ns plain><--(n,c) ::= . => \n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <ns plain><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <ns plain multi line>-->(n,'FLOW-OUT')\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <ns plain multi line>-->(n,'FLOW-IN')\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns plain one line>-->('BLOCK-KEY')\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <plain one line>-->('FLOW-KEY')\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<ns plain>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "/* [132] */ <nb ns plain in line><--(c) ::= <nb ns plain in line unit>-->(c)*\n"
  "/* [133] */ <ns plain one line><--(c) ::= <ns plain first>-->(c) <nb ns plain in line>-->(c)\n"
  "/* [134] */ <s ns plain next line><--(n,c) ::= <s flow folded>-->(n) <ns plain char>-->(c) <nb ns plain in line>-->(c)\n"
  "/* [135] */ <ns plain multi line><--(n,c) ::= <ns plain one line>-->(c) ( ( <s ns plain next line>-->(n,c)* ) )\n"
  "/* [136] */\n"
  "<in flow><--(n,c) ::= . => \n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <in flow><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <ns s flow seq entries>-->(n,'FLOW-IN')\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <ns s flow seq entries>-->(n,'FLOW-IN')\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns s flow seq entries>-->(n,'FLOW-KEY')\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns s flow seq entries>-->(n,'FLOW-KEY')\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<in flow>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "/* [137] */ <c flow sequence><--(n,c) ::=\n"
  "  <c sequence start>    # '['\n"
  "  <s separate maybe>-->(n,c)\n"
  "  <in flow maybe>-->(n,c)\n"
  "  <c sequence end>      # ']'\n"
  "\n"
  "/* [138] */ <ns s flow seq entries><--(n,c) ::= <ns flow seq entry>-->(n,c) <s separate maybe>-->(n,c)\n"
  "                                              | <ns flow seq entry>-->(n,c) <s separate maybe>-->(n,c) <c collect entry> /* ',' */ <s separate maybe>-->(n,c) <ns s flow seq entries maybe>-->(n,c)\n"
  "/* [139] */ <ns flow seq entry><--(n,c) ::= <ns flow pair>-->(n,c) | <ns flow node>-->(n,c)\n"
  "/* [140] */ <c flow mapping><--(n,c) ::=\n"
  "  <c mapping start>       # '{'\n"
  "  <s separate maybe>-->(n,c)\n"
  "  <ns s flow map entries maybe>-->(n,in_flow(c))\n"
  "  <c mapping end>         # '}'\n"
  "/* [141] */ <ns s flow map entries><--(n,c) ::= <ns flow map entry>-->(n,c) <s separate maybe>-->(n,c)\n"
  "                                              | <ns flow map entry>-->(n,c) <s separate maybe>-->(n,c) <c collect entry> /* ',' */ <s separate maybe>-->(n,c) <ns s flow map entries maybe>-->(n,c)\n"
  "/* [142] */ <ns flow map entry><--(n,c) ::=\n"
  "    (\n"
  "      <c mapping key>    # '?' (not followed by non-ws char)\n"
  "      <s separate>-->(n,c)\n"
  "      <ns flow map explicit entry>-->(n,c)\n"
  "    )\n"
  "  | <ns flow map implicit entry>-->(n,c)\n"
  "/* [143] */ <ns flow map explicit entry><--(n,c) ::=\n"
  "    <ns flow map implicit entry>-->(n,c)\n"
  "  | (\n"
  "      <e node>    # \"\"\n"
  "      <e node>    # \"\"\n"
  "    )\n"
  "/* [144] */ <ns flow map implicit entry><--(n,c) ::=\n"
  "    <ns flow map yaml key entry>-->(n,c)\n"
  "  | <c ns flow map empty key entry>-->(n,c)\n"
  "  | <c ns flow map json key entry>-->(n,c)\n"
  "/* [145] */ <ns flow map yaml key entry><--(n,c) ::=\n"
  "  <ns flow yaml node>-->(n,c)\n"
  "  (\n"
  "      (\n"
  "        <s separate maybe>-->(n,c)\n" 
  "        <c ns flow map separate value>-->(n,c)\n"
  "      )\n"
  "    | <e node>    # \"\"\n"
  "  )\n"
  "\n"
  "/* [146] */ <c ns flow map empty key entry><--(n,c) ::=\n"
  "  <e node>    # \"\"\n"
  "  <c ns flow map separate value>-->(n,c)\n"
  "\n"
  "/* [147] */ <c ns flow map separate value><--(n,c) ::=\n"
  "  <c mapping value>    # ':'\n"
  "  (?!<ns plain safe>-->(c))\n"
  "  (\n"
  "      (\n"
  "        <s separate>-->(n,c)\n"
  "        <ns flow node>-->(n,c)\n"
  "      )\n"
  "    | <e node>    # \"\"\n"
  "  )\n"
  "/* [148] */ <c ns flow map json key entry><--(n,c) ::=\n"
  "  <c flow json node>-->(n,c)\n"
  "  (\n"
  "      (\n"
  "        <s separate maybe>-->(n,c)\n"
  "        <c ns flow map adjacent value>-->(n,c)\n"
  "      )\n"
  "    | <e node>    # \"\"\n"
  "  )\n"
  "/* [149] */ <c ns flow map adjacent value><--(n,c) ::=\n"
  "  <c mapping value>          # ':'\n"
  "  (\n"
  "      (\n"
  "        <s separate maybe>-->(n,c)\n"
  "        <ns flow node>-->(n,c)\n"
  "      )\n"
  "    | <e node>    # \"\"\n"
  "  )\n"
  "/* [150] */ <ns flow pair><--(n,c) ::=\n"
  "    (\n"
  "      <c mapping key>     # '?' (not followed by non-ws char)\n"
  "      <s separate>-->(n,c)\n"
  "      <ns flow map explicit entry>-->(n,c)\n"
  "    )\n"
  "  | <ns flow pair entry>-->(n,c)\n"
  "/* [151] */ <ns flow pair entry><--(n,c) ::=\n"
  "    <ns flow pair yaml key entry>-->(n,c)\n"
  "  | <c ns flow map empty key entry>-->(n,c)\n"
  "  | <c ns flow pair json key entry>-->(n,c)\n"
  "/* [152] */ <ns flow pair yaml key entry><--(n,c) ::=\n"
  "  <ns s implicit yaml key>-->('FLOW-KEY')\n"
  "  <c ns flow map separate value>-->(n,c)\n"
  "/* [153] */ <c ns flow pair json key entry><--(n,c) ::=\n"
  "  <c s implicit json key>-->('FLOW-KEY')\n"
  "  <c ns flow map adjacent value>-->(n,c)\n"
  "/* [154] */ <ns s implicit yaml key><--(c) ::=\n"
  "  <ns flow yaml node>-->(0,c)\n"
  "  <s separate in line maybe>\n"
  "  /* At most 1024 characters altogether */\n"
  "/* [155] */ <c s implicit json key><--(c) ::=\n"
  "  <c flow json node>-->(0,c)\n"
  "  <s separate in line maybe>\n"
  "  /* At most 1024 characters altogether */\n"
  "/* [156] */ <ns flow yaml content><--(n,c) ::=\n"
  "  <ns plain>-->(n,c)\n"
  "/* [157] */ <c flow json content><--(n,c) ::=\n"
  "    <c flow sequence>-->(n,c)\n"
  "  | <c flow mapping>-->(n,c)\n"
  "  | <c single quoted>-->(n,c)\n"
  "  | <c double quoted>-->(n,c)\n"
  "/* [158] */ <ns flow content><--(n,c) ::=\n"
  "    <ns flow yaml content>-->(n,c)\n"
  "  | <c flow json content>-->(n,c)\n"
  "/* [159] */ <ns flow yaml node><--(n,c) ::=\n"
  "    <c ns alias node>\n"
  "  | <ns flow yaml content>-->(n,c)\n"
  "  | (\n"
  "      <c ns properties>-->(n,c)\n"
  "      (\n"
  "          (\n"
  "            <s separate>-->(n,c)\n"
  "            <ns flow yaml content>-->(n,c)\n"
  "          )\n"
  "        | <e scalar>\n"
  "      )\n"
  "    )\n"
  "/* [160] */ <c flow json node><--(n,c) ::= <c ns properties>-->(n,c) <s separate>-->(n,c) <c flow json content>-->(n,c)\n"
  "                                         |                                                <c flow json content>-->(n,c)\n"
  "\n"
  "/* [161] */ <ns flow node><--(n,c) ::=\n"
  "    <c ns alias node>\n"
  "  | <ns flow content>-->(n,c)\n"
  "  | (\n"
  "      <c ns properties>-->(n,c)\n"
  "      (\n"
  "        (\n"
  "          <s separate>-->(n,c)\n"
  "          <ns flow content>-->(n,c)\n"
  "        )\n"
  "        | <e scalar>\n"
  "      )\n"
  "    )\n"
  "/* [162] */ <c b block header><--(t) ::=\n"
  "  (\n"
  "      (\n"
  "        <c indentation indicator>\n"
  "        <c chomping indicator>-->(t)\n"
  "      )\n"
  "    | (\n"
  "        <c chomping indicator>-->(t)\n"
  "        <c indentation indicator>\n"
  "      )\n"
  "  )\n"
  "  <s b comment>\n"
  "/* [163] */ <c indentation indicator> ::= [\\x{31}-\\x{39}]    # 1-9\n"
  "/* [163 issue #230 ] */ <c indentation indicator> ::=          # empty string\n"
  "/* [164] */ <c chomping indicator><--(t) ::= . => \n"
  "                     ::luac->function(t)\n"
  "                               print('===========> <c chomping indicator><--('..tostring(t)..' [type: '..type(t)..'])')\n"
  "                               if (t == 'STRIP') then\n"
  "                                 return [[\n"
  "                                          '-'\n"
  "                                        ]]\n"
  "                               elseif (t == 'KEEP') then\n"
  "                                 return [[\n"
  "                                          '+'\n"
  "                                        ]]\n"
  "                               elseif (t == 'CLIP') then\n"
  "                                 return [[\n"
  "                                          /* Nothing */\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<c chomping indicator>: Invalid chomping: '..tostring(t))\n"
  "                               end\n"
  "                             end -->(t)\n"
  "/* [165] */ <b chomped last><--(t) ::= . =>\n"
  "                     ::luac->function(t)\n"
  "                               print('===========> <b chomped last><--('..tostring(t)..' [type: '..type(t)..'])')\n"
  "                               if (t == 'STRIP') then\n"
  "                                 return [[\n"
  "                                          ( <b non content> | :eof )\n"
  "                                        ]]\n"
  "                               elseif (t == 'KEEP') then\n"
  "                                 return [[\n"
  "                                          ( <b as line feed> | :eof )\n"
  "                                        ]]\n"
  "                               elseif (t == 'CLIP') then\n"
  "                                 return [[\n"
  "                                          ( <b as line feed> | :eof )\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<b chomped last>: Invalid chomping: '..tostring(t))\n"
  "                               end\n"
  "                             end -->(t)\n"
  "/* [166] */ <l chomped empty><--(n,t) ::= . => \n"
  "                     ::luac->function(n,t)\n"
  "                               print('===========> <l chomped empty><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(t)..' [type: '..type(t)..'])')\n"
  "                               if (t == 'STRIP') then\n"
  "                                 return [[\n"
  "                                          <l strip empty>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (t == 'KEEP') then\n"
  "                                 return [[\n"
  "                                          <l strip empty>-->(n)\n"
  "                                        ]]\n"
  "                               elseif (t == 'CLIP') then\n"
  "                                 return [[\n"
  "                                          <l keep empty>-->(n)\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<l chomped empty>: Invalid chomping: '..tostring(t))\n"
  "                               end\n"
  "                             end -->(n,t)\n"
  "/* [167] */ <l strip empty><--(n) ::= ( <l strip empty unit>-->(n)* ) <l trail comments maybe>-->(n)\n"
  "/* [168] */ <l keep empty><--(n) ::= ( <l keep empty unit>-->(n)* ) <l trail comments maybe>-->(n)\n"
  "/* [169] */ <l trail comments><--(n) ::=\n"
  "  <s indent less than>-->(n)\n"
  "  <c nb comment text>\n"
  "  <b comment>\n"
  "  ( <l comment>* )\n"
  "/* [170] */ <c l literal><--(n) ::=\n"
  "  <c literal>                # '|'\n"
  "  <c b block header>-->(t)\n"
  "  <l literal content>-->(n+m,t)\n"
  "/* [171] */ <l nb literal text><--(n) ::=\n"
  "  ( <l empty>-->(n,'BLOCK-IN')* )\n"
  "  <s indent>-->(n) ( <nb char>+ )\n"
  "/* [172] */ <b nb literal next><--(n) ::=\n"
  "  <b as line feed>\n"
  "  <l nb literal text>-->(n)\n"
  "/* [173] */ <l literal content><--(n,t) ::= <l nb literal text>-->(n) (<b nb literal next>-->(n)* ) <b chomped last>-->(t) <l chomped empty>-->(n,t)\n"
  "                                          |                                                                                <l chomped empty>-->(n,t)\n"
  "/* [174] */ <c l folded><--(n) ::=\n"
  "  <c folded>                 # '>'\n"
  "  <c b block header>-->(t)\n"
  "  <l folded content>-->(n+m,t)\n"
  "/* [175] */ <s nb folded text><--(n) ::=\n"
  "  <s indent>-->(n)\n"
  "  <ns char>\n"
  "  ( <nb char>* )\n"
  "/* [176] */ <l nb folded lines><--(n) ::=\n"
  "  <s nb folded text>-->(n)\n"
  "  ( <l nb folded lines unit>-->(n)* )\n"
  "/* [177] */ <s nb spaced text><--(n) ::=\n"
  "  <s indent>-->(n)\n"
  "  <s white>\n"
  "  ( <nb char>* )\n"
  "/* [178] */ <b l spaced><--(n) ::=\n"
  "  <b as line feed>\n"
  "  ( <l empty>-->(n,'BLOCK-IN')* )\n"
  "/* [179] */ <l nb spaced lines><--(n) ::=\n"
  "  <s nb spaced text>-->(n)\n"
  "  ( <l nb spaced lines unit>-->(n)* )\n"
  "/* [180] */ <l nb same lines><--(n) ::=\n"
  "  ( <l empty>-->(n,'BLOCK-IN')* )\n"
  "  (\n"
  "      <l nb folded lines>-->(n)\n"
  "    | <l nb spaced lines>-->(n)\n"
  "  )\n"
  "/* [181] */ <l nb diff lines><--(n) ::=\n"
  "  <l nb same lines>-->(n)\n"
  "  ( <l nb diff lines unit>-->(n)* )\n"
  "/* [182] */ <l folded content><--(n,t) ::= <l nb diff lines>-->(n) <b chomped last>-->(t) <l chomped empty>-->(n,t)\n"
  "                                         |                                                <l chomped empty>-->(n,t)\n"
  "\n"
  "/* [183] */ <l block sequence><--(n) ::= <l block sequence unit>-->(n)+\n"
  "/* [184] */ <c l block seq entry><--(n) ::=\n"
  "  <c sequence entry>    # '-'\n"
  "  (?!<ns char>)\n"
  "  <s l block indented>-->(n,'BLOCK-IN')\n"
  "/* [185] */ <s l block indented><--(n,c) ::=\n"
  "    (\n"
  "      <s indent>-->(m)\n"
  "      (\n"
  "          <ns l compact sequence>-->(n+1+m)\n"
  "        | <ns l compact mapping>-->(n+1+m)\n"
  "      )\n"
  "    )\n"
  "  | <s l block node>-->(n,c)\n"
  "  | (\n"
  "      <e node>    # \"\"\n"
  "      <s l comments>\n"
  "    )\n"
  "/* [186] */ <ns l compact sequence><--(n) ::=\n"
  "  <c l block seq entry>-->(n)\n"
  "  ( <ns l compact sequence unit>-->(n)* )\n"
  "/* [187] */ <l block mapping><--(n) ::= <l block mapping unit>-->(n)+\n"
  "/* [188] */ <ns l block map entry><--(n) ::=\n"
  "    <c l block map explicit entry>-->(n)\n"
  "  | <ns l block map implicit entry>-->(n)\n"
  "/* [189] */ <c l block map explicit entry><--(n) ::=\n"
  "  <c l block map explicit key>-->(n)\n"
  "  (\n"
  "      <l block map explicit value>-->(n)\n"
  "    | <e node>                        # \"\"\n"
  "  )\n"
  "/* [190] */ <c l block map explicit key><--(n) ::=\n"
  "  <c mapping key>                     # '?' (not followed by non-ws char)\n"
  "  <s l block indented>-->(n,'BLOCK-OUT')\n"
  "/* [191] */ <l block map explicit value><--(n) ::=\n"
  "  <s indent>-->(n)\n"
  "  <c mapping value>                   # ':' (not followed by non-ws char)\n"
  "  <s l block indented>-->(n,'BLOCK-OUT')\n"
  "/* [192] */ <ns l block map implicit entry><--(n) ::=\n"
  "  (\n"
  "      <ns s block map implicit key>\n"
  "    | <e node>    # \"\"\n"
  "  )\n"
  "  <c l block map implicit value>-->(n)\n"
  "/* [193] */ <ns s block map implicit key> ::=\n"
  "    <c s implicit json key>-->('BLOCK-KEY')\n"
  "  | <ns s implicit yaml key>-->('BLOCK-KEY')\n"
  "/* [194] */ <c l block map implicit value><--(n) ::=\n"
  "  <c mapping value>           # ':' (not followed by non-ws char)\n"
  "  (\n"
  "      <s l block node>-->(n,'BLOCK-OUT')\n"
  "    | (\n"
  "        <e node>    # \"\"\n"
  "        <s l comments>\n"
  "      )\n"
  "  )\n"
  "/* [195] */ <ns l compact mapping><--(n) ::=\n"
  "  <ns l block map entry>-->(n)\n"
  "  ( <ns l compact mapping unit>-->(n)* )\n"
  "/* [196] */ <s l block node><--(n,c) ::=\n"
  "    <s l block in block>-->(n,c)\n"
  "  | <s l flow in block>-->(n)\n"
  "/* [197] */ <s l flow in block><--(n) ::=\n"
  "  <s separate>-->(n+1,'FLOW-OUT')\n"
  "  <ns flow node>-->(n+1,'FLOW-OUT')\n"
  "  <s l comments>\n"
  "/* [198] */ <s l block in block><--(n,c) ::=\n"
  "    <s l block scalar>-->(n,c)\n"
  "  | <s l block collection>-->(n,c)\n"
  "/* [199] */ <s l block scalar><--(n,c) ::= <s separate>-->(n+1,c) <c ns properties>-->(n+1,c) <s separate>-->(n+1,c) ( <c l literal>-->(n) | <c l folded>-->(n) )\n"
  "                                         | <s separate>-->(n+1,c)                                                    ( <c l literal>-->(n) | <c l folded>-->(n) )\n"
  "/* [200] */ <s l block collection><--(n,c) ::= <s separate>-->(n+1,c) <c ns properties>-->(n+1,c) <s l comments> ( <seq space>-->(n,c) | <l block mapping>-->(n)  )\n"
  "                                             |                                                    <s l comments> ( <seq space>-->(n,c) | <l block mapping>-->(n)  )\n"
  "/* [201] */ <seq space><--(n,c) ::= . => \n"
  "                     ::luac->function(n,c)\n"
  "                               print('===========> <seq space><--('..tostring(n)..' [type: '..type(n)..'], '..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'BLOCK-OUT') then\n"
  "                                 return [[\n"
  "                                          <l block sequence>-->(n-1)\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-IN') then\n"
  "                                 return [[\n"
  "                                          <l block sequence>-->(n)\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<seq space>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(n,c)\n"
  "/* [202] */ <l document prefix> ::= <c byte order mark> ( <l comment>* )\n"
  "                                  |                     ( <l comment>* )\n"
  "/* [203] */ <c directives end> ::= \"---\"\n"
  "/* [204] */ <c document end> ::=\n"
  "  \"...\"    # (not followed by non-ws char)\n"
  "\n"
  "/* [205] */ <l document suffix> ::=\n"
  "  <c document end>\n"
  "  <s l comments>\n"
  "/* [206] */ <c forbidden> ::=\n"
  "  :sol\n"
  "  (\n"
  "      <c directives end>\n"
  "    | <c document end>\n"
  "  )\n"
  "  (\n"
  "      <b char>\n"
  "    | <s white>\n"
  "    | :eof\n"
  "  )\n"
  "/* [207] */ <l bare document> ::=\n"
  "  <s l block node>-->(-1,'BLOCK-IN')\n"
  "  /* Excluding c-forbidden content */\n"
  "/* [208] */ <l explicit document> ::=\n"
  "  <c directives end>\n"
  "  (\n"
  "      <l bare document>\n"
  "    | (\n"
  "        <e node>    # \"\"\n"
  "        <s l comments>\n"
  "      )\n"
  "  )\n"
  "/* [209] */ <l directive document> ::=\n"
  "  ( <l directive>+ )\n"
  "  <l explicit document>\n"
  "/* [210] */ <l any document> ::=\n"
  "    <l directive document>\n"
  "  | <l explicit document>\n"
  "  | <l bare document>\n"
  "\n"
  "#\n"
  "# Take care, <l document prefix> is a nullable>, and a nullable cannot be used as an RHS of a sequence rule\n"
  "# So we use explicitly sequences of <l document prefix not nullable>, replaced by an empty item wherever necessary\n"
  "#\n"
  "\n"
  "/* [211] */ <l yaml stream> ::= ( <l document prefix not nullable>* ) <l any document maybe> ( <l yaml stream unit>* )\n"
  "                              |                                       <l any document maybe> ( <l yaml stream unit>* )\n"
  "\n"
  "<l document prefix not nullable> ::= <c byte order mark> ( <l comment>+ )\n"
  "                                  |                      ( <l comment>+ )\n"
  "<l yaml stream unit> ::= ( <l document suffix>+ ) ( <l document prefix not nullable>* ) <l any document maybe>\n"
  "                       | ( <l document suffix>+ )                                       <l any document maybe>\n"
  "                       | <c byte order mark>\n"
  "                       | <l comment>\n"
  "                       | <l explicit document>\n"
  "\n"
  "#\n"
  "# Helpers\n"
  "# -------\n"
  "<ns directive name unit> ::= <s separate in line> <ns directive parameter>\n"
  "<nb ns double in line unit> ::= ( <s white>* ) <ns double char>\n"
  "<nb ns single in line unit> ::= ( <s white>* ) <ns single char>\n"
  "<ns plain safe minus c mapping value and c comment><--(c) ::= . => \n"
  "                     ::luac->function(c)\n"
  "                               print('===========> <ns plain safe minus c mapping value and c comment><--('..tostring(c)..' [type: '..type(c)..'])')\n"
  "                               if (c == 'FLOW-OUT') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe out minus c mapping value and c comment>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-IN') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe in minus c mapping value and c comment>\n"
  "                                        ]]\n"
  "                               elseif (c == 'BLOCK-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe out minus c mapping value and c comment>\n"
  "                                        ]]\n"
  "                               elseif (c == 'FLOW-KEY') then\n"
  "                                 return [[\n"
  "                                          <ns plain safe in minus c mapping value and c comment>\n"
  "                                        ]]\n"
  "                               else\n"
  "                                 error('<ns plain safe minus c mapping value and c comment>: Invalid context: '..tostring(c))\n"
  "                               end\n"
  "                             end -->(c)\n"
  "<ns plain safe out minus c mapping value and c comment> ::= /* <ns char> - <c mapping value> - <c comment> */\n"
  "                              # 8 bit\n"
  "   [\\x{21}\\x{22}\\x{24}-\\x{39}\\x{3B}-\\x{7E}]           # Printable ASCII minus <s space>, ':', '#'\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "\n"
  "<ns plain safe in minus c mapping value and c comment> ::= # <ns char> - <c flow indicator>\n"
  "                              # 8 bit\n"
  "   [\\x{21}\\x{22}\\x{24}-\\x{2B}\\x{2D}-\\x{39}\\x{3B}-\\x{5A}\\x{5C}\\x{5E}-\\x{7A}\\x{7C}\\x{7E}] # Printable ASCII minus <s space>, ',', '[', ']', '{', '}', ':', '#'\n"
  "                              # 16 bit\n"
  "  | [\\x{85}]                  # Next Line (NEL)\n"
  "  | [\\x{A0}-\\x{D7FF}]:u       # Basic Multilingual Plane (BMP)\n"
  "  | [\\x{E000}-\\x{FEFE}\\x{FF00}-\\x{FFFD}]:u     # Additional Unicode Areas minus 0xFEFF\n"
  "  | [\\x{010000}-\\x{10FFFF}]:u # 32 bit\n"
  "<nb ns plain in line unit><--(c) ::=\n"
  "    ( <s white>* )\n"
  "    <ns plain char>-->(c)\n"
  "<s separate maybe><--(n,c) ::= <s separate>-->(n,c)\n"
  "<s separate maybe><--(n,c) ::=\n"
  "<in flow maybe><--(n,c) ::= <in flow>-->(n,c)\n"
  "<in flow maybe><--(n,c) ::=\n"
  "<ns s flow seq entries maybe><--(n,c) ::= <ns s flow seq entries>-->(n,c)\n"
  "<ns s flow seq entries maybe><--(n,c) ::=\n"
  "<ns s flow map entries maybe><--(n,c) ::= <ns s flow map entries>-->(n,in_flow(c))\n"
  "<ns s flow map entries maybe><--(n,c) ::=\n"
  "<s separate in line maybe> ::= <s separate in line>\n"
  "<s separate in line maybe> ::=\n"
  "<l trail comments maybe><--(n) ::= <l trail comments>-->(n)\n"
  "<l trail comments maybe><--(n) ::=\n"
  "<l strip empty unit><--(n) ::= <s indent less or equal>-->(n) <b non content>\n"
  "<l keep empty unit><--(n) ::= <l empty>-->(n,'BLOCK-IN')\n"
  "<l nb folded lines unit><--(n) ::= <b l folded>-->(n,'BLOCK-IN') <s nb folded text>-->(n)\n"
  "<l nb spaced lines unit><--(n) ::= <b l spaced>-->(n) <s nb spaced text>-->(n)\n"
  "<l nb diff lines unit><--(n) ::= <b as line feed> <l nb same lines>-->(n)\n"
  "<l block sequence unit><--(n) ::= <s indent>-->(n+1+m) <c l block seq entry>-->(n+1+m)\n"
  "<ns l compact sequence unit><--(n) ::= <s indent>-->(n) <c l block seq entry>-->(n)\n"
  "<l block mapping unit><--(n) ::= <s indent>-->(n+1+m) <ns l block map entry>-->(n+1+m)\n"
  "<ns l compact mapping unit><--(n) ::= <s indent>-->(n) <ns l block map entry>-->(n)\n"
  "<l any document maybe> ::= <l any document>\n"
  "<l any document maybe> ::=\n"
  "\n"
  "<luascript>\n"
  "io.stdout:setvbuf 'no'\n"
  "io.stderr:setvbuf 'no'\n"
  "-- Indentation m is a global\n"
  "m = 0\n"
  "\n"
  "io.stdout:setvbuf 'no'    -- switch off buffering for stdout\n"
  "io.stderr:setvbuf 'no'    -- switch off buffering for stderr (not needed in practice)\n"
  "\n"
  "function pairsByKeys(t, f)\n"
  "   local a = {}\n"
  "   local k = {}\n"
  "   local v = {}\n"
  "   local i = 0\n"
  "   for n,m in pairs(t) do\n"
  "     i = i + 1\n"
  "     table.insert(a, i)\n"
  "     k[i] = n\n"
  "     v[i] = m\n"
  "   end\n"
  "   table.sort(a, f)\n"
  "   local j = 0      -- iterator variable\n"
  "   local iter = function ()   -- iterator function\n"
  "      j = j + 1\n"
  "      local key = k[a[j]]\n"
  "      local value = v[a[j]]\n"
  "      if key == nil then\n"
  "        return nil\n"
  "      else\n"
  "        return key, value\n"
  "      end\n"
  "   end\n"
  "   return iter\n"
  "end\n"
  "\n"
  "function _table2str(lua_table, raw_table, table_map, n, fold, indent)\n"
  "    indent = indent or 1\n"
  "    for k, v in pairsByKeys(lua_table) do\n"
  "        if type(k) == 'string' then\n"
  "            k = string.format('%q', k)\n"
  "        else\n"
  "            k = tostring(k)\n"
  "        end\n"
  "        n = n + 1; raw_table[n] = string.rep('    ', indent)\n"
  "        n = n + 1; raw_table[n] = '['\n"
  "        n = n + 1; raw_table[n] = k\n"
  "        n = n + 1; raw_table[n] = ']'\n"
  "        n = n + 1; raw_table[n] = ' = '\n"
  "        if type(v) == 'table' then\n"
  "            if fold and table_map[tostring(v)] then\n"
  "                n = n + 1; raw_table[n] = tostring(v)\n"
  "                n = n + 1; raw_table[n] = ',\\n'\n"
  "            else\n"
  "                table_map[tostring(v)] = true\n"
  "                n = n + 1; raw_table[n] = '{\\n'\n"
  "                n = _table2str(v, raw_table, table_map, n, fold, indent + 1)\n"
  "                n = n + 1; raw_table[n] = string.rep('    ', indent)\n"
  "                n = n + 1; raw_table[n] = '},\\n'\n"
  "            end\n"
  "        else\n"
  "            if type(v) == 'string' then\n"
  "                v = string.format('%q', v)\n"
  "            else\n"
  "                v = tostring(v)\n"
  "            end\n"
  "            n = n + 1; raw_table[n] = v\n"
  "            n = n + 1; raw_table[n] = ',\\n'\n"
  "        end\n"
  "    end\n"
  "    return n\n"
  "end\n"
  "\n"
  "function tableDump(lua_table, fold)\n"
  "    if type(lua_table) == 'table' then\n"
  "        local raw_table = {}\n"
  "        local table_map = {}\n"
  "        table_map[tostring(lua_table)] = true\n"
  "        local n = 0\n"
  "        n = n + 1; raw_table[n] = '{\\n'\n"
  "        n = _table2str(lua_table, raw_table, table_map, n, fold)\n"
  "        n = n + 1; raw_table[n] = '}'\n"
  "        return table.concat(raw_table, '')\n"
  "    else\n"
  "      if (lua_table == nil) then\n"
  "          return 'nil'\n"
  "      else\n"
  "        return lua_table\n"
  "      end\n"
  "    end\n"
  "end\n"
  "\n"
  "function in_flow(c)\n"
  "  print('===========> in_flow('..tostring(c)..' [type: '..type(c)..'])')\n"
  "  if (c == 'FLOW-OUT')  then return 'FLOW-IN'  end\n"
  "  if (c == 'FLOW-IN')   then return 'FLOW-IN'  end\n"
  "  if (c == 'BLOCK-KEY') then return 'FLOW-KEY' end\n"
  "  if (c == 'FLOW-KEY')  then return 'FLOW-KEY' end\n"
  "  error('in_flow: Invalid context: '..tostring(c))\n"
  "end\n"
  "</luascript>\n"
  "\n"
  ;

static char *inputs[] = {
  "---\n"
  " doe: \"a deer, a female deer\"\n"
  " ray: \"a drop of golden sun\"\n"
  " pi: 3.14159\n"
  " xmas: true\n"
  " french-hens: 3\n"
  " calling-birds:\n"
  "   - huey\n"
  "   - dewey\n"
  "   - louie\n"
  "   - fred\n"
  " xmas-fifth-day:\n"
  "   calling-birds: four\n"
  "   french-hens: 3\n"
  "   golden-rings: 5\n"
  "   partridges:\n"
  "     count: 1\n"
  "     location: \"a pear tree\"\n"
  "   turtle-doves: two\n"
    };

#endif /* YAML_GRAMMAR_C */
