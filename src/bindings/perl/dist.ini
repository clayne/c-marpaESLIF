name             = MarpaX-ESLIF
author           = Jean-Damien Durand <jeandamiendurand@free.fr>
license          = Perl_5
copyright_holder = Jean-Damien Durand
copyright_year   = 2017

; ---------------------------------------------------
; We use @Starter::Git with the following variations:
; ---------------------------------------------------

; Next version is provided by Git::NextVersion
; ---------------------------------------------------
[Git::NextVersion]
version_regexp = ^v?(\d+\.\d+\.\d+)$

; "# VERSION" and "# AUTHORITY" annotations
; ---------------------------------------------------
[OurPkgVersion]
[Authority]
locate_comment = 1

; Pod are managed using Pod::Weaver::PluginBundle::RJBS
; ---------------------------------------------------
; - Because he knows how to insert Contributor section before Legal section
; - We add that explicitly to DevelopRequires because it seems it is not automatically discovered.
[Git::Contributors]
[PodWeaver]
config_plugin = @RJBS
[Prereqs / DevelopRequires ]
Pod::Weaver::PluginBundle::RJBS = 0

; Add authordeps as develop/requires
; ---------------------------------------------------
[Prereqs::AuthorDeps]

; Add xt tests
; ---------------------------------------------------
[Test::Perl::Critic]                ; xt/author/critic.t
[MetaTests]                         ; xt/author/distmeta.t
[Test::EOL]                         ; xt/author/eol.t
[Test::MinimumVersion]              ; xt/author/minimum-version.t
[MojibakeTests]                     ; xt/author/mojibake.t
[Test::NoTabs]                      ; xt/author/no-tabs.t
[Test::Pod::Coverage::Configurable] ; xt/author/pod-coverage.t
also_private = allocate             ; Defined in the XS
also_private = allocate_newFrom     ; Defined in the XS
also_private = meta_allocate        ; Defined in the XS
also_private = regex_allocate       ; Defined in the XS
also_private = string_allocate      ; Defined in the XS
also_private = dispose              ; Defined in the XS
also_private = constant             ; A bug IMHO
trustme = MarpaX::ESLIF::Grammar::Symbol::Properties => qr/^(?:new)$/ ; Used in the XS - completely internal
trustme = MarpaX::ESLIF::Grammar::Rule::Properties => qr/^(?:new)$/ ; Used in the XS - completely internal
[Test::Pod::LinkCheck]              ; xt/author/pod-linkcheck.t
[Test::Portability]                 ; xt/author/portability.t
options = test_one_dot = 0
[Test::Synopsis]                    ; xt/author/synopsis.t
[Test::Version]                     ; xt/author/test-version.t
[Test::CPAN::Changes]               ; xt/release/cpan-changes.t
[Test::Kwalitee]                    ; xt/release/kwalitee.t
skiptest = has_readme               ; It is normal we do not have README, metacpan tells everything that is needed.
[Test::CPAN::Meta::JSON]            ; xt/release/meta-json.t

; Meta resources use [AutoMetaResources] convenient %{dist} to set homepage, [GitHub::Meta] for the rest
; ---------------------------------------------------
[AutoMetaResources]
homepage = https://metacpan.org/release/%{dist}
[GitHub::Meta]
homepage = 0

; Find prereqs
; ------------
[AutoPrereqs]

; Some hardcoded prereqs because of MakeMaker::Awesome hooks (see below)
; ----------------------------------------------------------------------
[Prereqs / ConfigureRequires]
Archive::Tar = 0 ; used by inner CMakeObjects.PL's
Config = 0
Config::AutoConf = 0
Config::AutoConf::INI = 0.005 ; used by inner CMakeObjects.PL's
Cwd = 0
diagnostics = 0
ExtUtils::CBuilder = 0.280224 ; 0.280224 is to make sure we have the support of $ENV{CXX}
ExtUtils::Constant = 0
File::Basename = 0
File::chdir = 0
File::Copy = 0
File::Copy::Recursive = 0
File::Find = 0
File::Path = 0
File::Spec = 0
File::Temp = 0
File::Which = 0
IO::Handle = 0
Perl::OSType = 0
POSIX = 0
strict = 0
Try::Tiny = 0

[Prereqs / ConfigureSuggests]
; Well, ExtUtils::CppGuess does not install everywhere, in particular there is a problem with Sun C compiler.
; This is why we have an explicit copy in our inc that we enclose with a try/catch
ExtUtils::CppGuess = 0.26

[Prereqs / TestRequires]
Test::More = 1.3
Test::Deep = 1.128

; We distribute some files that are binary: this will instruct AutoPrereqs to skip them
; --------------------------------------------------------------------------------------
[Encoding]
encoding = bytes
match = \.gz$
match = \.gif$
match = \.png$
match = \btestdata\b

; Determine minimum perl version
; ---------------------------------------------------
[MinimumPerl]

; Generate a cpanfile
; ---------------------------------------------------
[CPANFile]

; Generate a Changes file
; ---------------------------------------------------
[ChangelogFromGit::CPAN::Changes]
show_author = 0                   ; This is just adding noise to the Changes file - go to git directly for more details
file_name = Changes
tag_regexp  = ^v?(\d+\.\d+\.\d+)$

; Why does it copy cmake/* under src if I say
; [GatherDir / SpecFiles]
; root   = src
; prefix = src
; !?
[GatherDir / src]
root   = src
prefix = src/.

[GatherFile]
filename = .perlcriticrc ; Explicitly add it for xtest

[PruneFiles]                 ; Additional stuff to skip
match = \b3rdparty\b.*\.pod$ ; Documentation from 3rdparties

[PodnameFromClassname] ; For Moops

; @Starter::Git Bundle with regeneration of:
; Makefile.PL
; META.json
; README.pod
; ---------------------------------------------------
[@Starter::Git]
revision = 5
-remove = Pod2Readme
Test::Compile.xt_mode = 0
Git::Check.allow_dirty[0] = Changes
Git::Check.allow_dirty[1] = META.json
Git::Check.allow_dirty[2] = README.pod
Git::Check.allow_dirty[3] = Makefile.PL
Git::Check.allow_dirty[4] = cpanfile
Git::Check.allow_dirty[5] = lib/MarpaX/ESLIF/BNF.pod ; Generated from upper directory
Git::Check.allow_dirty[6] = lib/MarpaX/ESLIF/Introduction.pod ; Generated from upper directory
Git::Check.allow_dirty[7] = lib/MarpaX/ESLIF/Bindings.pod ; Generated from upper directory
Git::Check.untracked_files = warn ; For the case where generated files do not yet exist
PruneCruft.except[0] = ^\.perlcriticrc$
regenerate = Changes
regenerate = META.json
regenerate = README.pod
regenerate = Makefile.PL
regenerate = cpanfile
installer = MakeMaker::Awesome
MakeMaker::Awesome.eumm_version = 7.20  ; C.f. https://github.com/Perl-Toolchain-Gang/ExtUtils-MakeMaker/pull/275
MakeMaker::Awesome.delimiter = |
MakeMaker::Awesome.header[  0] = |my $have_cppguess;
MakeMaker::Awesome.header[  1] = |BEGIN {
MakeMaker::Awesome.header[  2] = |  use File::Spec;                     # Formally it is not necessary I believe to do it here
MakeMaker::Awesome.header[  3] = |  # Make sure we have our 'inc' directory prepended the perl search path
MakeMaker::Awesome.header[  4] = |  my $inc_dir = File::Spec->catdir(File::Spec->curdir, 'inc');
MakeMaker::Awesome.header[  5] = |  unshift(@INC, $inc_dir);
MakeMaker::Awesome.header[  6] = |  #
MakeMaker::Awesome.header[  7] = |  # ExtUtils::CppGuess does not install everywhere.
MakeMaker::Awesome.header[  8] = |  # This is why we provide it explicitely, we are ok if it fails at run-time
MakeMaker::Awesome.header[  9] = |  # by enclosing its usage in try/catch
MakeMaker::Awesome.header[ 10] = |  #
MakeMaker::Awesome.header[ 11] = |  $have_cppguess = eval 'use ExtUtils::CppGuess 0.26; 1;';
MakeMaker::Awesome.header[ 12] = |}
MakeMaker::Awesome.header[ 13] = |use Config;
MakeMaker::Awesome.header[ 14] = |use Config::AutoConf;
MakeMaker::Awesome.header[ 15] = |use ExtUtils::CBuilder;
MakeMaker::Awesome.header[ 16] = |use Cwd qw/abs_path/;
MakeMaker::Awesome.header[ 17] = |use ExtUtils::Constant qw /constant_types C_constant XS_constant autoload/;
MakeMaker::Awesome.header[ 18] = |use File::Basename;
MakeMaker::Awesome.header[ 19] = |use File::Find;
MakeMaker::Awesome.header[ 20] = |use File::Which;
MakeMaker::Awesome.header[ 21] = |use IO::Handle;
MakeMaker::Awesome.header[ 22] = |use Perl::OSType qw/is_os_type/;
MakeMaker::Awesome.header[ 23] = |use Try::Tiny;
MakeMaker::Awesome.header[ 24] = |
MakeMaker::Awesome.header[ 25] = |autoflush STDOUT 1;
MakeMaker::Awesome.header[ 26] = |autoflush STDERR 1;
MakeMaker::Awesome.header[ 27] = |
MakeMaker::Awesome.header[ 28] = |#
MakeMaker::Awesome.header[ 29] = |# Our distribution have both C and CPP files, and we want to make sure that modifying
MakeMaker::Awesome.header[ 30] = |# CFLAGS will not affect cpp files. Since we require a version of ExtUtils::CBuilder
MakeMaker::Awesome.header[ 31] = |# that support the environment variables, explicitely setting the environment variables
MakeMaker::Awesome.header[ 32] = |# from default ExtUtils::Cbuilder will ensure cc and cpp settings will become independant
MakeMaker::Awesome.header[ 33] = |# if we are doing to modify any of them.
MakeMaker::Awesome.header[ 34] = |# We do that for linker settings as well for coherency although we will NEVER touch them.
MakeMaker::Awesome.header[ 35] = |# OTHERLDFLAGS will be specific to this makefile.
MakeMaker::Awesome.header[ 36] = |#
MakeMaker::Awesome.header[ 37] = |# Take care: with ExtUtils::CBuilder, $ENV{CFLAGS} and $ENV{LDFLAGS} are appended to default perl compile flags, not the others
MakeMaker::Awesome.header[ 38] = |#
MakeMaker::Awesome.header[ 39] = |#
MakeMaker::Awesome.header[ 40] = |my %cbuilder_config = ExtUtils::CBuilder->new()->get_config;
MakeMaker::Awesome.header[ 41] = |$ENV{CC} = $cbuilder_config{cc} // 'cc';
MakeMaker::Awesome.header[ 42] = |$ENV{CFLAGS} //= '';
MakeMaker::Awesome.header[ 43] = |$ENV{CFLAGS} .= ' -DNDEBUG';
MakeMaker::Awesome.header[ 44] = |$ENV{CXX} = $cbuilder_config{cxx} // $ENV{CC};
MakeMaker::Awesome.header[ 45] = |$ENV{CXXFLAGS} = $cbuilder_config{cxxflags} // $cbuilder_config{ccflags} // '';
MakeMaker::Awesome.header[ 46] = |$ENV{LD} = $cbuilder_config{ld} // $ENV{CC};
MakeMaker::Awesome.header[ 47] = |$ENV{LDFLAGS} //= '';
MakeMaker::Awesome.header[ 48] = |# OTHERLDFLAGS remains local and must affect ONLY this process, not sub-processes
MakeMaker::Awesome.header[ 49] = |my @OTHERLDFLAGS = ();
MakeMaker::Awesome.header[ 60] = |#
MakeMaker::Awesome.header[ 61] = |print "==========================================\n";
MakeMaker::Awesome.header[ 62] = |print "Original compilers and linker settings as per ExtUtils::CBuilder\n";
MakeMaker::Awesome.header[ 63] = |print "\n";
MakeMaker::Awesome.header[ 64] = |print "CC           (overwrite) $ENV{CC}\n";
MakeMaker::Awesome.header[ 65] = |print "CFLAGS       (    fixed) " . ($cbuilder_config{ccflags} // '') . "\n";
MakeMaker::Awesome.header[ 66] = |print "CFLAGS       (   append) $ENV{CFLAGS}\n";
MakeMaker::Awesome.header[ 67] = |print "CXX          (overwrite) $ENV{CXX}\n";
MakeMaker::Awesome.header[ 68] = |print "CXXFLAGS     (overwrite) $ENV{CXXFLAGS}\n";
MakeMaker::Awesome.header[ 69] = |print "LD           (overwrite) $ENV{LD}\n";
MakeMaker::Awesome.header[ 70] = |print "LDFLAGS      (    fixed) " . ($cbuilder_config{ldflags} // '') . "\n";
MakeMaker::Awesome.header[ 71] = |print "LDFLAGS      (   append) $ENV{LDFLAGS}\n";
MakeMaker::Awesome.header[ 72] = |print "==========================================\n";
MakeMaker::Awesome.header[ 73] = |print "\n";
MakeMaker::Awesome.header[ 74] = |
MakeMaker::Awesome.header[ 75] = |my $ac = Config::AutoConf->new();
MakeMaker::Awesome.header[ 76] = |$ac->check_cc;
MakeMaker::Awesome.header[ 77] = |
MakeMaker::Awesome.header[ 78] = |#
MakeMaker::Awesome.header[ 79] = |# We want to align lua integer type with perl ivtype
MakeMaker::Awesome.header[ 80] = |#
MakeMaker::Awesome.header[ 81] = |my $ivtype = $Config{ivtype} || '';
MakeMaker::Awesome.header[ 82] = |if ($ivtype eq 'int') {
MakeMaker::Awesome.header[ 83] = |  $ac->msg_notice("Use int for lua_Integer");
MakeMaker::Awesome.header[ 84] = |  $ENV{CFLAGS} .= " -DLUA_INT_TYPE=1";
MakeMaker::Awesome.header[ 85] = |  $ENV{CXXFLAGS} .= " -DLUA_INT_TYPE=1";
MakeMaker::Awesome.header[ 86] = |} elsif ($ivtype eq 'long') {
MakeMaker::Awesome.header[ 87] = |  $ac->msg_notice("Use long for lua_Integer");
MakeMaker::Awesome.header[ 88] = |  $ENV{CFLAGS} .= " -DLUA_INT_TYPE=2";
MakeMaker::Awesome.header[ 89] = |  $ENV{CXXFLAGS} .= " -DLUA_INT_TYPE=2";
MakeMaker::Awesome.header[ 90] = |} elsif ($ivtype eq 'long long') {
MakeMaker::Awesome.header[ 91] = |  $ac->msg_notice("Use long long for lua_Integer");
MakeMaker::Awesome.header[ 92] = |  $ENV{CFLAGS} .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 93] = |  $ENV{CXXFLAGS} .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 94] = |} else {
MakeMaker::Awesome.header[ 95] = |  $ac->msg_notice("No exact map found in lua for perl integer type \"$ivtype\": use long long for lua_Integer");
MakeMaker::Awesome.header[ 96] = |  $ENV{CFLAGS} .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 97] = |  $ENV{CXXFLAGS} .= " -DLUA_INT_TYPE=3";
MakeMaker::Awesome.header[ 98] = |}
MakeMaker::Awesome.header[ 99] = |
MakeMaker::Awesome.header[100] = |#
MakeMaker::Awesome.header[101] = |# We want to align lua float type with perl nvtype
MakeMaker::Awesome.header[102] = |#
MakeMaker::Awesome.header[103] = |my $nvtype = $Config{nvtype} || '';
MakeMaker::Awesome.header[104] = |if ($nvtype eq 'float') {
MakeMaker::Awesome.header[105] = |  $ac->msg_notice("Use float for lua_Number");
MakeMaker::Awesome.header[106] = |  $ENV{CFLAGS} .= " -DLUA_FLOAT_TYPE=1";
MakeMaker::Awesome.header[107] = |  $ENV{CXXFLAGS} .= " -DLUA_FLOAT_TYPE=1";
MakeMaker::Awesome.header[108] = |} elsif ($nvtype eq 'double') {
MakeMaker::Awesome.header[109] = |  $ac->msg_notice("Use double for lua_Number");
MakeMaker::Awesome.header[110] = |  $ENV{CFLAGS} .= " -DLUA_FLOAT_TYPE=2";
MakeMaker::Awesome.header[111] = |  $ENV{CXXFLAGS} .= " -DLUA_FLOAT_TYPE=2";
MakeMaker::Awesome.header[112] = |} elsif ($nvtype eq 'long double') {
MakeMaker::Awesome.header[113] = |  $ac->msg_notice("Use long double for lua_Number");
MakeMaker::Awesome.header[114] = |  $ENV{CFLAGS} .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[115] = |  $ENV{CXXFLAGS} .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[116] = |} else {
MakeMaker::Awesome.header[117] = |  $ac->msg_notice("No exact map found in lua for perl double type \"$nvtype\": use long double for lua_Number");
MakeMaker::Awesome.header[118] = |  $ENV{CFLAGS} .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[119] = |  $ENV{CXXFLAGS} .= " -DLUA_FLOAT_TYPE=3";
MakeMaker::Awesome.header[120] = |}
MakeMaker::Awesome.header[121] = |#
MakeMaker::Awesome.header[122] = |# Guess CXX configuration
MakeMaker::Awesome.header[123] = |#
MakeMaker::Awesome.header[124] = |#
MakeMaker::Awesome.header[125] = |# Sun C compiler is a special case, we know that guess_compiler will always get it wrong
MakeMaker::Awesome.header[126] = |#
MakeMaker::Awesome.header[127] = |my $sunc = 0;
MakeMaker::Awesome.header[128] = |$ac->msg_checking(sprintf "if this is Sun C compiler");
MakeMaker::Awesome.header[129] = |if ($ac->link_if_else("#ifdef __SUNPRO_C\n#else\n#error \"this is not Sun C compiler\"\n#endif\nint main() { return 0; }")) {
MakeMaker::Awesome.header[130] = |  $ac->msg_result('yes');
MakeMaker::Awesome.header[131] = |  my $cc = which($ENV{CC}) || '';
MakeMaker::Awesome.header[132] = |  if (! $cc) {
MakeMaker::Awesome.header[133] = |    #
MakeMaker::Awesome.header[134] = |    # Should never happen since we checked that the compiler works
MakeMaker::Awesome.header[135] = |    #
MakeMaker::Awesome.header[136] = |    $ac->msg_notice("Warning! Sun C compiler working but which() on its location returned false !?");
MakeMaker::Awesome.header[137] = |  } else {
MakeMaker::Awesome.header[138] = |    #
MakeMaker::Awesome.header[139] = |    # $cc should be a full path
MakeMaker::Awesome.header[140] = |    #
MakeMaker::Awesome.header[141] = |    $cc = abs_path($cc);
MakeMaker::Awesome.header[142] = |    my $ccdir = dirname($cc) || File::Spec->curdir();
MakeMaker::Awesome.header[143] = |    my $cxx = File::Spec->catfile($ccdir, 'CC');
MakeMaker::Awesome.header[144] = |    # We always give precedence to CC that should be at the same location of the C compiler
MakeMaker::Awesome.header[145] = |    #
MakeMaker::Awesome.header[146] = |    if (! which($cxx)) {
MakeMaker::Awesome.header[147] = |      #
MakeMaker::Awesome.header[148] = |      # No CC at the same location?
MakeMaker::Awesome.header[149] = |      #
MakeMaker::Awesome.header[150] = |      $ac->msg_notice("Warning! Sun C compiler detected but no CC found at the same location - trying with default search path");
MakeMaker::Awesome.header[151] = |      $cxx = 'CC';
MakeMaker::Awesome.header[152] = |    } else {
MakeMaker::Awesome.header[153] = |      #
MakeMaker::Awesome.header[154] = |      # Could it be that this CC is also the one that is, eventually, in the path?
MakeMaker::Awesome.header[155] = |      #
MakeMaker::Awesome.header[156] = |      my $cxxfromPATH = which('CC') || '';
MakeMaker::Awesome.header[157] = |      if ($cxxfromPATH) {
MakeMaker::Awesome.header[158] = |        $cxxfromPATH = abs_path($cxxfromPATH);
MakeMaker::Awesome.header[159] = |        my $cxxfromWhich = abs_path($cxx);
MakeMaker::Awesome.header[160] = |        if ($cxxfromWhich eq $cxxfromPATH) {
MakeMaker::Awesome.header[161] = |          $ac->msg_notice("Sun C compiler detected and its CC counterpart is already in the search path");
MakeMaker::Awesome.header[162] = |          $cxx = 'CC';
MakeMaker::Awesome.header[163] = |        }
MakeMaker::Awesome.header[164] = |      }
MakeMaker::Awesome.header[165] = |    }
MakeMaker::Awesome.header[166] = |    if (which($cxx)) {
MakeMaker::Awesome.header[167] = |      $ac->msg_notice("Forcing CXX to $cxx");
MakeMaker::Awesome.header[168] = |      $ENV{CXX} = $cxx;
MakeMaker::Awesome.header[169] = |      #
MakeMaker::Awesome.header[170] = |      # We got "CC" executable - no need of eventual -x c++ that perl may have add
MakeMaker::Awesome.header[171] = |      #
MakeMaker::Awesome.header[172] = |      if ($ENV{CXXFLAGS} =~ s/\-x\s+c\+\+\s*//) {
MakeMaker::Awesome.header[173] = |        $ac->msg_notice("Removed -x c++ from CXXFLAGS");
MakeMaker::Awesome.header[174] = |      }
MakeMaker::Awesome.header[175] = |    } else {
MakeMaker::Awesome.header[176] = |      $ac->msg_notice("Warning! Sun C compiler detected but no CC found neither in path neither where is the C compiler");
MakeMaker::Awesome.header[177] = |    }
MakeMaker::Awesome.header[178] = |    #
MakeMaker::Awesome.header[179] = |    # In any case, add -lCrun and do not execute guess_compiler - cross fingers if we did not managed to find CXX
MakeMaker::Awesome.header[180] = |    #
MakeMaker::Awesome.header[181] = |    $ac->msg_notice("Adding -lCrun to OTHERLDFLAGS");
MakeMaker::Awesome.header[182] = |    push(@OTHERLDFLAGS, '-lCrun');
MakeMaker::Awesome.header[183] = |    $sunc = 1;
MakeMaker::Awesome.header[184] = |  }
MakeMaker::Awesome.header[185] = |} else {
MakeMaker::Awesome.header[186] = |  $ac->msg_result('no');
MakeMaker::Awesome.header[187] = |}
MakeMaker::Awesome.header[188] = |if ($have_cppguess && ! $sunc) {
MakeMaker::Awesome.header[189] = |  try {
MakeMaker::Awesome.header[190] = |    my ($cxx_guess, $extra_cxxflags_guess, $extra_ldflags_guess) = guess_compiler($ac);
MakeMaker::Awesome.header[191] = |    if (defined($cxx_guess) && (length($cxx_guess) > 0) && which($cxx_guess)) {
MakeMaker::Awesome.header[192] = |      $ac->msg_notice("Setting CXX to $cxx_guess");
MakeMaker::Awesome.header[193] = |      $ENV{CXX} = $cxx_guess;
MakeMaker::Awesome.header[194] = |      if (defined($extra_cxxflags_guess) && (length($extra_cxxflags_guess) > 0)) {
MakeMaker::Awesome.header[195] = |        $ac->msg_notice("Appending $extra_cxxflags_guess to CXXFLAGS");
MakeMaker::Awesome.header[196] = |        $ENV{CXXFLAGS} .= " $extra_cxxflags_guess";
MakeMaker::Awesome.header[197] = |      }
MakeMaker::Awesome.header[198] = |      if (defined($extra_ldflags_guess) && (length($extra_ldflags_guess) > 0)) {
MakeMaker::Awesome.header[199] = |        $ac->msg_notice("Pushing $extra_ldflags_guess to OTHERLDFLAGS");
MakeMaker::Awesome.header[200] = |        push(@OTHERLDFLAGS, $extra_ldflags_guess) ;
MakeMaker::Awesome.header[201] = |      }
MakeMaker::Awesome.header[202] = |    }
MakeMaker::Awesome.header[203] = |  };
MakeMaker::Awesome.header[204] = |}
MakeMaker::Awesome.header[205] = |if ((! "$ENV{CXX}") || (! which($ENV{CXX}))) {
MakeMaker::Awesome.header[206] = |  $ac->msg_notice("Fallback mode trying to guess from C compiler");
MakeMaker::Awesome.header[207] = |  my $cc_basename = basename($ENV{CC});
MakeMaker::Awesome.header[208] = |  my $cc_dirname = dirname($ENV{CC});
MakeMaker::Awesome.header[209] = |  #
MakeMaker::Awesome.header[210] = |  # Traditionally xxxxcc becomes xxxx++
MakeMaker::Awesome.header[211] = |  #
MakeMaker::Awesome.header[212] = |  if ($cc_basename =~ /cc$/i) {
MakeMaker::Awesome.header[213] = |    my $cxx_basename = $cc_basename;
MakeMaker::Awesome.header[214] = |    $cxx_basename =~ s/cc$/++/;
MakeMaker::Awesome.header[215] = |    my $cxx = File::Spec->catfile($cc_dirname, $cxx_basename);
MakeMaker::Awesome.header[216] = |    if (which($cxx)) {
MakeMaker::Awesome.header[217] = |      $ac->msg_notice("Setting CXX to found $cxx");
MakeMaker::Awesome.header[218] = |      $ENV{CXX} = $cxx;
MakeMaker::Awesome.header[219] = |    }
MakeMaker::Awesome.header[220] = |  }
MakeMaker::Awesome.header[221] = |  #
MakeMaker::Awesome.header[222] = |  # Or xxxxlang becomes lang++
MakeMaker::Awesome.header[223] = |  #
MakeMaker::Awesome.header[224] = |  elsif ($cc_basename =~ /lang$/i) {
MakeMaker::Awesome.header[225] = |    my $cxx_basename = $cc_basename;
MakeMaker::Awesome.header[226] = |    $cxx_basename .= "++";
MakeMaker::Awesome.header[227] = |    my $cxx = File::Spec->catfile($cc_dirname, $cxx_basename);
MakeMaker::Awesome.header[228] = |    if (which($cxx)) {
MakeMaker::Awesome.header[229] = |      $ac->msg_notice("Setting CXX to found $cxx");
MakeMaker::Awesome.header[230] = |      $ENV{CXX} = $cxx;
MakeMaker::Awesome.header[231] = |    }
MakeMaker::Awesome.header[232] = |  }
MakeMaker::Awesome.header[233] = |  #
MakeMaker::Awesome.header[234] = |  # Cross fingers, and use C compiler
MakeMaker::Awesome.header[235] = |  #
MakeMaker::Awesome.header[236] = |  else {
MakeMaker::Awesome.header[237] = |    $ac->msg_notice("Setting CXX to fallback $ENV{CC}");
MakeMaker::Awesome.header[238] = |    $ENV{CXX} = $ENV{CC};
MakeMaker::Awesome.header[239] = |  }
MakeMaker::Awesome.header[240] = |}
MakeMaker::Awesome.header[241] = |
MakeMaker::Awesome.header[242] = |# -------------
MakeMaker::Awesome.header[243] = |# CC and CFLAGS
MakeMaker::Awesome.header[244] = |# --------------
MakeMaker::Awesome.header[245] = |#
MakeMaker::Awesome.header[246] = |my $isc99 = 0;
MakeMaker::Awesome.header[247] = |if (($cbuilder_config{cc} // 'cc') ne 'cl') {
MakeMaker::Awesome.header[248] = |    $ac->msg_checking("if C99 is enabled by default:");
MakeMaker::Awesome.header[249] = |    if (try_compile("#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L\n#error \"C99 is not enabled\"\n#endif\nint main(){return 0;}")) {
MakeMaker::Awesome.header[250] = |        $ac->msg_result('yes');
MakeMaker::Awesome.header[251] = |        $isc99 = 1;
MakeMaker::Awesome.header[252] = |    } else {
MakeMaker::Awesome.header[253] = |        $ac->msg_result('no');
MakeMaker::Awesome.header[254] = |        $ac->msg_notice("what CFLAGS is required for C99:");
MakeMaker::Awesome.header[255] = |        $ac->msg_result('');
MakeMaker::Awesome.header[256] = |        foreach my $flag (qw/-std=gnu99 -std=c99 -c99 -AC99 -xc99=all -qlanglvl=extc99/) {
MakeMaker::Awesome.header[257] = |            $ac->msg_checking("if flag $flag works:");
MakeMaker::Awesome.header[258] = |            if (try_compile("#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L\n#error \"C99 is not enabled\"\n#endif\nint main(){return 0;}", $flag)) {
MakeMaker::Awesome.header[259] = |                $ac->msg_result('yes');
MakeMaker::Awesome.header[260] = |                $ENV{CFLAGS} .= " $flag";
MakeMaker::Awesome.header[261] = |                $isc99 = 1;
MakeMaker::Awesome.header[262] = |                last;
MakeMaker::Awesome.header[263] = |            } else {
MakeMaker::Awesome.header[264] = |                $ac->msg_result('no');
MakeMaker::Awesome.header[265] = |            }
MakeMaker::Awesome.header[266] = |        }
MakeMaker::Awesome.header[267] = |    }
MakeMaker::Awesome.header[268] = |}
MakeMaker::Awesome.header[269] = |
MakeMaker::Awesome.header[270] = |#
MakeMaker::Awesome.header[271] = |# When the compiler is clang, there is a bug with inlining, c.f. for example
MakeMaker::Awesome.header[272] = |# https://sourceforge.net/p/resil/tickets/6/
MakeMaker::Awesome.header[273] = |#
MakeMaker::Awesome.header[274] = |if (is_os_type('Unix', 'darwin') && ! $isc99)
MakeMaker::Awesome.header[275] = |{
MakeMaker::Awesome.header[276] = |  $ac->msg_checking(sprintf "if this is clang compiler");
MakeMaker::Awesome.header[277] = |  if ($ac->link_if_else("#ifndef __clang__\n#error \"this is not clang compiler\"\n#endif\nint main() { return 0; }")) {
MakeMaker::Awesome.header[278] = |      $ac->msg_result('yes');
MakeMaker::Awesome.header[279] = |      #
MakeMaker::Awesome.header[280] = |      # C.f. http://clang.llvm.org/compatibility.html#inline
MakeMaker::Awesome.header[281] = |      #      https://bugzilla.mozilla.org/show_bug.cgi?id=917526
MakeMaker::Awesome.header[282] = |      #
MakeMaker::Awesome.header[283] = |      $ac->msg_notice("Adding -std=gnu89 to CFLAGS for inline semantics");
MakeMaker::Awesome.header[284] = |      $ENV{CFLAGS} .= ' -std=gnu89';
MakeMaker::Awesome.header[285] = |  } else {
MakeMaker::Awesome.header[286] = |      $ac->msg_result('no');
MakeMaker::Awesome.header[287] = |  }
MakeMaker::Awesome.header[288] = |}
MakeMaker::Awesome.header[289] = |
MakeMaker::Awesome.header[290] = |if ($^O eq "netbsd" && ! $isc99) {
MakeMaker::Awesome.header[291] = |  #
MakeMaker::Awesome.header[292] = |  # We need long long, that C99 guarantees, else _NETBSD_SOURCE will do it
MakeMaker::Awesome.header[293] = |  #
MakeMaker::Awesome.header[294] = |  $ac->msg_notice("NetBSD platform: Append _NETBSD_SOURCE to CFLAGS to have long long");
MakeMaker::Awesome.header[295] = |  $ENV{CFLAGS} .= ' -D_NETBSD_SOURCE';
MakeMaker::Awesome.header[296] = |}
MakeMaker::Awesome.header[297] = |
MakeMaker::Awesome.header[298] = |#
MakeMaker::Awesome.header[299] = |# On windows we are using dlfcn-win32 that will imply a dependency on psapi. We verify this library is available
MakeMaker::Awesome.header[300] = |#
MakeMaker::Awesome.header[301] = |
MakeMaker::Awesome.header[302] = |if (is_os_type('Windows')) {
MakeMaker::Awesome.header[303] = |  $ac->msg_notice("Windows platform: Append -D__NO_INLINE__ to CFLAGS and CXXFLAGS");
MakeMaker::Awesome.header[304] = |  $ENV{CFLAGS} .= ' -D__NO_INLINE__';
MakeMaker::Awesome.header[305] = |  $ENV{CXXFLAGS} .= ' -D__NO_INLINE__';
MakeMaker::Awesome.header[306] = |  $ac->msg_notice("Windows platform: Determining the need for -lpsapi");
MakeMaker::Awesome.header[307] = |  $ac->push_libraries('psapi');
MakeMaker::Awesome.header[308] = |  if ($ac->link_if_else("#include <windows.h>\n#include <psapi.h>\nint main() { EnumProcessModules(NULL, NULL, 0, NULL); }")) {
MakeMaker::Awesome.header[309] = |    if (basename($Config{cc}) =~ /^cl/i) {
MakeMaker::Awesome.header[310] = |      $ac->msg_notice("Windows platform: Adding psapi.lib to OTHERLDFLAGS");
MakeMaker::Awesome.header[311] = |      push(@OTHERLDFLAGS, "psapi.lib");
MakeMaker::Awesome.header[312] = |    } else {
MakeMaker::Awesome.header[313] = |      $ac->msg_notice("Windows platform: Adding -lpsapi to OTHERLDFLAGS");
MakeMaker::Awesome.header[314] = |      push(@OTHERLDFLAGS, "-lpsapi");
MakeMaker::Awesome.header[315] = |    }
MakeMaker::Awesome.header[316] = |  }
MakeMaker::Awesome.header[317] = |}
MakeMaker::Awesome.header[318] = |
MakeMaker::Awesome.header[319] = |# goto no_tweak_on_optimization_flags;
MakeMaker::Awesome.header[320] = |$ac->msg_checking("optimization flags:");
MakeMaker::Awesome.header[321] = |$ac->msg_result('');
MakeMaker::Awesome.header[322] = |if (($cbuilder_config{cc} // 'cc') eq 'cl') {
MakeMaker::Awesome.header[323] = |    foreach my $flag ("/O2") {
MakeMaker::Awesome.header[324] = |        $ac->msg_checking("if flag $flag works:");
MakeMaker::Awesome.header[325] = |        if (try_compile("#include <stdlib.h>\nint main() {\n  exit(0);\n}\n", $flag)) {
MakeMaker::Awesome.header[326] = |            $ac->msg_result('yes');
MakeMaker::Awesome.header[327] = |            $ENV{PERL_EXTUTILS_CBUILDER_CONFIG_optimize} .= " $flag";
MakeMaker::Awesome.header[328] = |            last;
MakeMaker::Awesome.header[329] = |        } else {
MakeMaker::Awesome.header[330] = |            $ac->msg_result('no');
MakeMaker::Awesome.header[331] = |        }
MakeMaker::Awesome.header[332] = |    }
MakeMaker::Awesome.header[333] = |} else {
MakeMaker::Awesome.header[334] = |    #
MakeMaker::Awesome.header[335] = |    # Some versions of gcc may not yell with bad options unless -Werror is set.
MakeMaker::Awesome.header[336] = |    # Check that flag and set it temporarly.
MakeMaker::Awesome.header[337] = |    #
MakeMaker::Awesome.header[338] = |    my $tmpflag = '-Werror';
MakeMaker::Awesome.header[339] = |    $ac->msg_checking("if flag $tmpflag works:");
MakeMaker::Awesome.header[340] = |    if (try_compile("#include <stdlib.h>\nint main() {\n  exit(0);\n}\n", $tmpflag)) {
MakeMaker::Awesome.header[341] = |        $ac->msg_result('yes');
MakeMaker::Awesome.header[342] = |    } else {
MakeMaker::Awesome.header[343] = |        $ac->msg_result('no');
MakeMaker::Awesome.header[344] = |        $tmpflag = '';
MakeMaker::Awesome.header[345] = |    }
MakeMaker::Awesome.header[346] = |
MakeMaker::Awesome.header[347] = |    #
MakeMaker::Awesome.header[348] = |    # We test AIX case first because it overlaps with general O3
MakeMaker::Awesome.header[349] = |    #
MakeMaker::Awesome.header[350] = |    foreach my $flag ("-O3 -qstrict", # xlc
MakeMaker::Awesome.header[351] = |                      "-O3",          # cl, gcc
MakeMaker::Awesome.header[352] = |                      "-xO3"          # CC
MakeMaker::Awesome.header[353] = |                      ) {
MakeMaker::Awesome.header[354] = |        $ac->msg_checking("if flag $flag works:");
MakeMaker::Awesome.header[355] = |        if (try_compile("#include <stdlib.h>\nint main() {\n  exit(0);\n}\n", "$tmpflag $flag")) {
MakeMaker::Awesome.header[356] = |            $ac->msg_result('yes');
MakeMaker::Awesome.header[357] = |            $ENV{PERL_EXTUTILS_CBUILDER_CONFIG_optimize} .= " $flag";
MakeMaker::Awesome.header[358] = |            last;
MakeMaker::Awesome.header[359] = |        } else {
MakeMaker::Awesome.header[360] = |            $ac->msg_result('no');
MakeMaker::Awesome.header[361] = |        }
MakeMaker::Awesome.header[362] = |    }
MakeMaker::Awesome.header[363] = |}
MakeMaker::Awesome.header[364] = |no_tweak_on_optimization_flags:
MakeMaker::Awesome.header[365] = |
MakeMaker::Awesome.header[366] = |my $OTHERLDFLAGS = join(' ', @OTHERLDFLAGS);
MakeMaker::Awesome.header[367] = |print "\n";
MakeMaker::Awesome.header[368] = |print "==========================================\n";
MakeMaker::Awesome.header[369] = |print "Tweaked compilers and linker settings\n";
MakeMaker::Awesome.header[370] = |print "\n";
MakeMaker::Awesome.header[371] = |print "CC           (overwrite) $ENV{CC}\n";
MakeMaker::Awesome.header[372] = |print "CFLAGS       (    fixed) " . ($cbuilder_config{ccflags} // '') . "\n";
MakeMaker::Awesome.header[373] = |print "CFLAGS       (   append) $ENV{CFLAGS}\n";
MakeMaker::Awesome.header[374] = |print "CXX          (overwrite) $ENV{CXX}\n";
MakeMaker::Awesome.header[375] = |print "CXXFLAGS     (overwrite) $ENV{CXXFLAGS}\n";
MakeMaker::Awesome.header[376] = |print "LD           (overwrite) $ENV{LD}\n";
MakeMaker::Awesome.header[377] = |print "LDFLAGS      (    fixed) " . ($cbuilder_config{ldflags} // '') . "\n";
MakeMaker::Awesome.header[378] = |print "LDFLAGS      (   append) $ENV{LDFLAGS}\n";
MakeMaker::Awesome.header[379] = |print "OTHERLDFLAGS             $OTHERLDFLAGS\n";
MakeMaker::Awesome.header[380] = |print "==========================================\n";
MakeMaker::Awesome.header[381] = |print "\n";
MakeMaker::Awesome.header[382] = |
MakeMaker::Awesome.header[383] = |my $fh;
MakeMaker::Awesome.header[384] = |print "Generating constant types\n";
MakeMaker::Awesome.header[385] = |open($fh, '>', 'c-constant-types.inc') || die "Cannot open c-constant-types.inc, $!";
MakeMaker::Awesome.header[386] = |print $fh constant_types();
MakeMaker::Awesome.header[387] = |close($fh) || warn "Failed to close c-constant-types.inc, $!";
MakeMaker::Awesome.header[388] = |
MakeMaker::Awesome.header[389] = |my %types = ( 'event' => { pkg => 'MarpaX::ESLIF::Event::Type', constants => [qw/MARPAESLIF_EVENTTYPE_NONE MARPAESLIF_EVENTTYPE_COMPLETED MARPAESLIF_EVENTTYPE_NULLED MARPAESLIF_EVENTTYPE_PREDICTED MARPAESLIF_EVENTTYPE_BEFORE MARPAESLIF_EVENTTYPE_AFTER MARPAESLIF_EVENTTYPE_EXHAUSTED MARPAESLIF_EVENTTYPE_DISCARD/] }, 'value' => { pkg => 'MarpaX::ESLIF::Value::Type', constants => [qw/MARPAESLIF_VALUE_TYPE_UNDEF MARPAESLIF_VALUE_TYPE_CHAR MARPAESLIF_VALUE_TYPE_SHORT MARPAESLIF_VALUE_TYPE_INT MARPAESLIF_VALUE_TYPE_LONG MARPAESLIF_VALUE_TYPE_FLOAT MARPAESLIF_VALUE_TYPE_DOUBLE MARPAESLIF_VALUE_TYPE_PTR MARPAESLIF_VALUE_TYPE_ARRAY MARPAESLIF_VALUE_TYPE_BOOL MARPAESLIF_VALUE_TYPE_STRING MARPAESLIF_VALUE_TYPE_ROW MARPAESLIF_VALUE_TYPE_TABLE MARPAESLIF_VALUE_TYPE_LONG_DOUBLE/] }, 'loggerLevel' => { pkg => 'MarpaX::ESLIF::Logger::Level', constants => [qw/GENERICLOGGER_LOGLEVEL_TRACE GENERICLOGGER_LOGLEVEL_DEBUG GENERICLOGGER_LOGLEVEL_INFO GENERICLOGGER_LOGLEVEL_NOTICE GENERICLOGGER_LOGLEVEL_WARNING GENERICLOGGER_LOGLEVEL_ERROR GENERICLOGGER_LOGLEVEL_CRITICAL GENERICLOGGER_LOGLEVEL_ALERT GENERICLOGGER_LOGLEVEL_EMERGENCY/] }, 'rulePropertyBitSet' => { pkg => 'MarpaX::ESLIF::Rule::PropertyBitSet', constants => [qw/MARPAESLIF_RULE_IS_ACCESSIBLE MARPAESLIF_RULE_IS_NULLABLE MARPAESLIF_RULE_IS_NULLING MARPAESLIF_RULE_IS_LOOP MARPAESLIF_RULE_IS_PRODUCTIVE/] }, 'symbolPropertyBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::PropertyBitSet', constants => [qw/MARPAESLIF_SYMBOL_IS_ACCESSIBLE MARPAESLIF_SYMBOL_IS_NULLABLE MARPAESLIF_SYMBOL_IS_NULLING MARPAESLIF_SYMBOL_IS_PRODUCTIVE MARPAESLIF_SYMBOL_IS_START MARPAESLIF_SYMBOL_IS_TERMINAL/] }, 'symbolEventBitSet' => { pkg => 'MarpaX::ESLIF::Symbol::EventBitSet', constants => [qw/MARPAESLIF_SYMBOL_EVENT_COMPLETION MARPAESLIF_SYMBOL_EVENT_NULLED MARPAESLIF_SYMBOL_EVENT_PREDICTION/] }, 'symbol' => { pkg => 'MarpaX::ESLIF::Symbol::Type', constants => [qw/MARPAESLIF_SYMBOLTYPE_TERMINAL MARPAESLIF_SYMBOLTYPE_META/] });
MakeMaker::Awesome.header[390] = |
MakeMaker::Awesome.header[391] = |foreach (sort keys %types) {
MakeMaker::Awesome.header[392] = |  my $pkg = $types{$_}->{pkg};
MakeMaker::Awesome.header[393] = |  print "Generating $pkg C $_ types\n";
MakeMaker::Awesome.header[394] = |  open($fh, '>', "c-$_-types.inc") || die "Cannot open c-$_-types.inc, $!";
MakeMaker::Awesome.header[395] = |  print $fh C_constant($pkg, "${_}_constant", undef, undef, undef, undef, @{$types{$_}->{constants}});
MakeMaker::Awesome.header[396] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[397] = |
MakeMaker::Awesome.header[398] = |  # This is a bit vicious but in our case these are NOT macros but ENUMS !
MakeMaker::Awesome.header[399] = |  # We know what were are doing and replace all #ifdef MARPAESLIF_xxx and #ifdef GENERICLOGGER_xxx by #if 1
MakeMaker::Awesome.header[400] = |
MakeMaker::Awesome.header[401] = |  print "Tweaking $pkg C $_ types to work with enums\n";
MakeMaker::Awesome.header[402] = |  open($fh, '<', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[403] = |  my $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[404] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[405] = |  $content =~ s/^#\s*ifdef\s+(?:MARPAESLIF_|GENERICLOGGER_).*?$/#if 1/smg;
MakeMaker::Awesome.header[406] = |  open($fh, '>', "c-$_-types.inc") || die "Failed to open c-$_-types.inc, $!";
MakeMaker::Awesome.header[407] = |  print $fh $content;
MakeMaker::Awesome.header[408] = |  close($fh) || warn "Failed to close c-$_-types.inc, $!";
MakeMaker::Awesome.header[409] = |
MakeMaker::Awesome.header[410] = |  print "Generating $pkg XS $_ types\n";
MakeMaker::Awesome.header[411] = |  open($fh, '>', "xs-$_-types.inc") || die "Cannot open xs-$_-types.inc, $!";
MakeMaker::Awesome.header[412] = |  print $fh XS_constant($pkg, 'IV', 'constant', "${_}_constant");
MakeMaker::Awesome.header[413] = |  close($fh) || warn "Failed to close xs-$_-types.inc, $!";
MakeMaker::Awesome.header[414] = |
MakeMaker::Awesome.header[415] = |  print "Generating $pkg AUTOLOAD\n";
MakeMaker::Awesome.header[416] = |  my $autoload = replace_autoload_tabs(autoload($pkg, '5.10', 1));
MakeMaker::Awesome.header[417] = |
MakeMaker::Awesome.header[418] = |  my @pkg = split(/::/, $pkg);
MakeMaker::Awesome.header[419] = |  $pkg[-1] .= '.pm';
MakeMaker::Awesome.header[420] = |  my $pkgfile = File::Spec->catfile('lib', @pkg);
MakeMaker::Awesome.header[421] = |  print "Pushing AUTOLOAD into $pkgfile\n";
MakeMaker::Awesome.header[422] = |  open($fh, '<', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[423] = |  $content = do { local $/; <$fh> };
MakeMaker::Awesome.header[424] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[425] = |  $content =~ s/^#\s*AUTOLOAD.*?$/\n$autoload\n/sm;
MakeMaker::Awesome.header[426] = |  open($fh, '>', $pkgfile) || die "Failed to open $pkgfile, $!";
MakeMaker::Awesome.header[427] = |  print $fh $content;
MakeMaker::Awesome.header[428] = |  close($fh) || warn "Failed to close $pkgfile, $!";
MakeMaker::Awesome.header[429] = |}
MakeMaker::Awesome.header[430] = |
MakeMaker::Awesome.header[431] = |check_src();
MakeMaker::Awesome.header[432] = |my_spawn($^X, File::Spec->catfile('src', 'CMakeObjects.PL'));
MakeMaker::Awesome.header[433] = |my @ldfrom = ();
MakeMaker::Awesome.header[434] = |my %unique = ();
MakeMaker::Awesome.header[435] = |find({ wanted => sub {
MakeMaker::Awesome.header[436] = |                       if (-f $_) {
MakeMaker::Awesome.header[437] = |                         my $cpath = File::Spec->canonpath($_);
MakeMaker::Awesome.header[438] = |                         if (basename(dirname($cpath)) eq 'obj4perl') {
MakeMaker::Awesome.header[439] = |                           if (! ${unique}{basename($cpath)}++) {
MakeMaker::Awesome.header[440] = |                             push(@ldfrom, $cpath);
MakeMaker::Awesome.header[441] = |                           }
MakeMaker::Awesome.header[442] = |                         }
MakeMaker::Awesome.header[443] = |                       }
MakeMaker::Awesome.header[444] = |                     },
MakeMaker::Awesome.header[445] = |      no_chdir => 1 }, File::Spec->curdir);
MakeMaker::Awesome.header[446] = |
MakeMaker::Awesome.header[447] = |print "Linking ESLIF\$(OBJ_EXT) using: @ldfrom\n";
MakeMaker::Awesome.header[448] = |
MakeMaker::Awesome.header[449] = |#
MakeMaker::Awesome.header[450] = |# Inspired by Inline-CPP-0.74/inc/ILCPPConfig/CompilerGuess.pm
MakeMaker::Awesome.header[451] = |#
MakeMaker::Awesome.header[452] = |sub guess_compiler {
MakeMaker::Awesome.header[453] = |  my ($ac) = @_;
MakeMaker::Awesome.header[454] = |
MakeMaker::Awesome.header[455] = |  my $guesser = ExtUtils::CppGuess->new(cc => $ENV{CC});
MakeMaker::Awesome.header[456] = |  #
MakeMaker::Awesome.header[457] = |  # We work quite like Module::Build in the sense that we are appending
MakeMaker::Awesome.header[458] = |  # flags.
MakeMaker::Awesome.header[459] = |  #
MakeMaker::Awesome.header[460] = |  my %module_build_options = $guesser->module_build_options;
MakeMaker::Awesome.header[461] = |  my $cxx_guess            = $module_build_options{config}->{cc} // '';
MakeMaker::Awesome.header[462] = |  my $extra_cxxflags_guess = $module_build_options{extra_compiler_flags} // '';
MakeMaker::Awesome.header[463] = |  my $extra_ldflags_guess  = $module_build_options{extra_linker_flags} // '';
MakeMaker::Awesome.header[464] = |  $ac->msg_notice("ExtUtils::CppGuess says \$cxx_guess=$cxx_guess, \$extra_cxxflags_guess=$extra_cxxflags_guess, \$extra_ldflags_guess=$extra_ldflags_guess");
MakeMaker::Awesome.header[465] = |
MakeMaker::Awesome.header[466] = |  return ($cxx_guess, $extra_cxxflags_guess, $extra_ldflags_guess);
MakeMaker::Awesome.header[467] = |}
MakeMaker::Awesome.header[468] = |
MakeMaker::Awesome.header[469] = |sub try_compile {
MakeMaker::Awesome.header[470] = |    my ($csource, $extra_compiler_flags) = @_;
MakeMaker::Awesome.header[471] = |
MakeMaker::Awesome.header[472] = |    my $fh = File::Temp->new(UNLINK => 0, SUFFIX => '.c');
MakeMaker::Awesome.header[473] = |    print $fh "$csource\n";
MakeMaker::Awesome.header[474] = |    close($fh);
MakeMaker::Awesome.header[475] = |    my $source = $fh->filename;
MakeMaker::Awesome.header[476] = |    my $rc = 0;
MakeMaker::Awesome.header[477] = |
MakeMaker::Awesome.header[478] = |    try {
MakeMaker::Awesome.header[479] = |        my $cbuilder = ExtUtils::CBuilder->new();
MakeMaker::Awesome.header[480] = |        my $obj = basename($cbuilder->object_file($source));
MakeMaker::Awesome.header[481] = |        $cbuilder->compile(
MakeMaker::Awesome.header[482] = |            source               => $source,
MakeMaker::Awesome.header[483] = |            object_file          => $obj,
MakeMaker::Awesome.header[484] = |            extra_compiler_flags => $extra_compiler_flags
MakeMaker::Awesome.header[485] = |            );
MakeMaker::Awesome.header[486] = |        $rc = 1;
MakeMaker::Awesome.header[487] = |    };
MakeMaker::Awesome.header[488] = |    unlink $fh->filename;
MakeMaker::Awesome.header[489] = |
MakeMaker::Awesome.header[490] = |    return $rc;
MakeMaker::Awesome.header[491] = |}
MakeMaker::Awesome.header[492] = |
MakeMaker::Awesome.header[493] = |sub my_spawn {
MakeMaker::Awesome.header[494] = |    my (@cmd) = @_;
MakeMaker::Awesome.header[495] = |
MakeMaker::Awesome.header[496] = |    die "Empty command to execute" unless @cmd;
MakeMaker::Awesome.header[497] = |
MakeMaker::Awesome.header[498] = |    print "=== Command: @cmd\n";
MakeMaker::Awesome.header[499] = |
MakeMaker::Awesome.header[500] = |    my $pid = fork() // die "Failed to fork, $!";
MakeMaker::Awesome.header[501] = |    $pid ? my_spawn_parent_side($pid, @cmd) : my_spawn_child_side(@cmd);
MakeMaker::Awesome.header[502] = |}
MakeMaker::Awesome.header[503] = |
MakeMaker::Awesome.header[504] = |sub my_spawn_child_side {
MakeMaker::Awesome.header[505] = |    my (@cmd) = @_;
MakeMaker::Awesome.header[506] = |
MakeMaker::Awesome.header[507] = |    exec { $cmd[0] } @cmd;
MakeMaker::Awesome.header[508] = |    die "=== Command: @cmd, $!"; # Should never be executed
MakeMaker::Awesome.header[509] = |}
MakeMaker::Awesome.header[510] = |
MakeMaker::Awesome.header[511] = |sub my_spawn_parent_side {
MakeMaker::Awesome.header[512] = |    my ($pid, @cmd ) = @_;
MakeMaker::Awesome.header[513] = |
MakeMaker::Awesome.header[514] = |    my $kid = waitpid($pid, 0);
MakeMaker::Awesome.header[515] = |    warn "=== Command: @cmd, waitpid on PID $pid returned child PID $kid?" unless $kid == $pid;
MakeMaker::Awesome.header[516] = |    my $exit_value = $? >> 8;
MakeMaker::Awesome.header[517] = |    my $signal = $? & 127;
MakeMaker::Awesome.header[518] = |    my $core_dump = $? & 128;
MakeMaker::Awesome.header[519] = |    if ($exit_value) {
MakeMaker::Awesome.header[520] = |        die "=== Command: @cmd, exit value $exit_value (signal=$signal, core_dump=$core_dump)\n";
MakeMaker::Awesome.header[521] = |    } else {
MakeMaker::Awesome.header[522] = |        print STDOUT "=== Command: @cmd, exit value $exit_value\n";
MakeMaker::Awesome.header[523] = |    }
MakeMaker::Awesome.header[524] = |}
MakeMaker::Awesome.header[525] = |
MakeMaker::Awesome.header[526] = |#
MakeMaker::Awesome.header[527] = |# Quite painful: generated autoload contains tabs that Test::NoTabs will detect!
MakeMaker::Awesome.header[528] = |# Just replacing it with spaces would perturb viewing the file.
MakeMaker::Awesome.header[529] = |# Fortunately we /know/ how it looks like:
MakeMaker::Awesome.header[530] = |#
MakeMaker::Awesome.header[531] = |#    if ($error) {
MakeMaker::Awesome.header[532] = |#	if ($error =~  /is not a valid/) {
MakeMaker::Awesome.header[533] = |#	    $AutoLoader::AUTOLOAD = $AUTOLOAD;
MakeMaker::Awesome.header[534] = |#	    goto &AutoLoader::AUTOLOAD;
MakeMaker::Awesome.header[535] = |#	} else {
MakeMaker::Awesome.header[536] = |#	    croak $error;
MakeMaker::Awesome.header[537] = |#	}
MakeMaker::Awesome.header[538] = |#    }
MakeMaker::Awesome.header[539] = |#    {
MakeMaker::Awesome.header[540] = |#	no strict 'refs';
MakeMaker::Awesome.header[541] = |#	# Fixed between 5.005_53 and 5.005_61
MakeMaker::Awesome.header[542] = |##XXX	if ($] >= 5.00561) {
MakeMaker::Awesome.header[543] = |##XXX	    *$AUTOLOAD = sub () { $val };
MakeMaker::Awesome.header[544] = |##XXX	}
MakeMaker::Awesome.header[545] = |##XXX	else {
MakeMaker::Awesome.header[546] = |#	    *$AUTOLOAD = sub { $val };
MakeMaker::Awesome.header[547] = |##XXX	}
MakeMaker::Awesome.header[548] = |#    }
MakeMaker::Awesome.header[549] = |#
MakeMaker::Awesome.header[550] = |sub replace_autoload_tabs {
MakeMaker::Awesome.header[551] = |    my ($autoload) = @_;
MakeMaker::Awesome.header[552] = |    $autoload =~ s/^\t/        /mg; # For the cases we know for pretty indentation
MakeMaker::Awesome.header[553] = |    $autoload =~ s/\t/    /g; # For all the other cases
MakeMaker::Awesome.header[554] = |    return $autoload;
MakeMaker::Awesome.header[555] = |}
MakeMaker::Awesome.header[556] = |
MakeMaker::Awesome.header[557] = |sub check_src {
MakeMaker::Awesome.header[558] = |    if (! -d 'src') {
MakeMaker::Awesome.header[559] = |        print "#########################################################################\n";
MakeMaker::Awesome.header[560] = |        print "No src directory - Assuming you are in a c-marpaESLIF repository checkout\n";
MakeMaker::Awesome.header[561] = |        print "#########################################################################\n";
MakeMaker::Awesome.header[562] = |        my_spawn($^X, File::Spec->catfile('etc', 'copyDirs.PL'));
MakeMaker::Awesome.header[563] = |    }
MakeMaker::Awesome.header[564] = |}
MakeMaker::Awesome.header[565] = |
MakeMaker::Awesome.WriteMakefile_arg[0] = OBJECT => 'ESLIF$(OBJ_EXT)'
MakeMaker::Awesome.WriteMakefile_arg[1] = LDFROM => join(' ', '$(OBJECT)', @ldfrom)
MakeMaker::Awesome.WriteMakefile_arg[2] = dynamic_lib => { OTHERLDFLAGS => join(' ', @OTHERLDFLAGS) }
MakeMaker::Awesome.WriteMakefile_arg[3] = INC => join(' ', map { "-I$_ " } (File::Spec->catdir('src', 'output', 'include'), File::Spec->catdir('src', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericLogger', 'output', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericLogger', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericStack', 'include'), File::Spec->catdir('src', 'output', '3rdparty', 'genericHash', 'include') ) )

[DynamicPrereqs]
-delimiter = |
-raw = |use Config;
-raw = |if (! $Config{usethreads}) {
-raw = |  foreach (qw/PREREQ_PM BUILD_REQUIRES TEST_REQUIRES/) {
-raw = |    delete($WriteMakefileArgs{$_}{Thread}) if (exists($WriteMakefileArgs{$_}));
-raw = |    delete($FallbackPrereqs{$_}{Thread})   if (exists($FallbackPrereqs{$_}));
-raw = |  }
-raw = |}
